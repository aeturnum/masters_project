% !TEX options=--shell-escape
% https://github.com/SublimeText/LaTeXTools/issues/1082
%  _____ _             _    ______             __ _ __  
% |  ___(_)_ __   __ _| |  / /  _ \ _ __ __ _ / _| |\ \ 
% | |_  | | '_ \ / _` | | | || | | | '__/ _` | |_| __| |
% |  _| | | | | | (_| | | | || |_| | | | (_| |  _| |_| |
% |_|   |_|_| |_|\__,_|_| | ||____/|_|  \__,_|_|  \__| |
%                          \_\                      /_/ 
                   
% -------------------------------------------------------------------------
% https://www.kammerl.de/ascii/AsciiSignature.php - standard
% I've moved beyond justifying latex and am now just living in it.


% Use APA module
% Based on template from https://www.overleaf.com/latex/templates/your-apa6-style-manuscript/kngbbqpypjcq
\documentclass[a4paper,man,natbib,floatsintext]{apa6}
% Imports natbib
% Ref Sheet: https://gking.harvard.edu/files/natnotes2.pdf

% Packages
% Unicode in latex is a new, previously undiscovered circle of hell
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage{textcomp}
% /unicode
\usepackage{amsmath}
\usepackage{graphicx}
% allow single spacing
\usepackage{setspace}
% glossary
\usepackage[acronym]{glossaries}
% fancy quotes
\usepackage{epigraph, varwidth}
% For formatting of potential bibliography
\usepackage{enumitem}
% html links
\usepackage{hyperref}
%\usepackage[colorinlistoftodos]{todonotes}
% Allow seperate footnotes
\usepackage{sepfootnotes}
% adding spaces around paragraphs
% https://tex.stackexchange.com/questions/74170/have-new-line-between-paragraphs-no-indentation
%\usepackage{parskip}
% Diagrams!
\usepackage{svg}
\usepackage{graphicx}
% vertical space around list items
\usepackage{enumitem}
% small font in verbatum
% https://tex.stackexchange.com/questions/171803/change-font-size-of-the-verbatim-environment
\usepackage{fancyvrb}

% image location
\graphicspath{ {images/} }
% less space in bulleted lists
\setlist{nosep}
% set single spacing



% Trying to include graphics has been a JOURNEY
% Links used:
% aborted attempt to use svgs
% https://tex.stackexchange.com/questions/542766/inkscape-1-0-not-able-to-export-files-needed-for-svg-package
% https://tex.stackexchange.com/questions/2099/how-to-include-svg-diagrams-in-latex
% (updated comand line is: inkscape -D --export-latex  "EDEN_diagram.svg" --export-type="pdf" --export-filename="EDEN_diagram_svg-tex.pdf")
% https://www.overleaf.com/learn/latex/Inserting_Images
% convert EDEN_diagram.png -resize 50% EDEN_diagram.png


% This section was found in a stack overflow comment about making the epigraph length different and I include it here as an incantation against bad formatting
\renewcommand{\epigraphsize}{\small}
\setlength{\epigraphwidth}{0.6\textwidth}
\renewcommand{\textflush}{flushright}
\renewcommand{\sourceflush}{flushright}
% A useful addition
\newcommand{\epitextfont}{\itshape}
\newcommand{\episourcefont}{\scshape}

\makeatletter
\newsavebox{\epi@textbox}
\newsavebox{\epi@sourcebox}
\newlength\epi@finalwidth
\renewcommand{\epigraph}[2]{%
  \vspace{\beforeepigraphskip}
  {\epigraphsize\begin{\epigraphflush}
   \epi@finalwidth=\z@
   \sbox\epi@textbox{%
     \varwidth{\epigraphwidth}
     \begin{\textflush}\epitextfont#1\end{\textflush}
     \endvarwidth
   }%
   \epi@finalwidth=\wd\epi@textbox
   \sbox\epi@sourcebox{%
     \varwidth{\epigraphwidth}
     \begin{\sourceflush}\episourcefont#2\end{\sourceflush}%
     \endvarwidth
   }%
   \ifdim\wd\epi@sourcebox>\epi@finalwidth 
     \epi@finalwidth=\wd\epi@sourcebox
   \fi
   \leavevmode\vbox{
     \hb@xt@\epi@finalwidth{\hfil\box\epi@textbox}
     \vskip1.75ex
     \hrule height \epigraphrule
     \vskip.75ex
     \hb@xt@\epi@finalwidth{\hfil\box\epi@sourcebox}
   }%
   \end{\epigraphflush}
   \vspace{\afterepigraphskip}}}
\makeatother
% End epigraph modifications

\makenoidxglossaries
% These used to be in a seperate file, but I want them in here because it will let me cite things from the bibliography in them

%   _____ _                                
%  / ____| |                               
% | |  __| | ___  ___ ___  __ _ _ __ _   _ 
% | | |_ | |/ _ \/ __/ __|/ _` | '__| | | |
% | |__| | | (_) \__ \__ \ (_| | |  | |_| |
%  \_____|_|\___/|___/___/\__,_|_|   \__, |
%                                     __/ |
%                                    |___/ 


\newacronym{foss}{FOSS}{Free Open Source Software}
\newacronym{sts}{STS}{Science, Technology \& Society}
\newacronym{ict}{ICT}{Information and Communications Technology}
\newacronym{eden}{Eden}{Emergency Development ENvironment}
\newacronym{ict4d}{ICT4D}{Information and Communication Technologies for Development}


\newglossaryentry{ICT}
{
    name=Information and communications technology,
    description={Information and communications technology: A term for the mix of physical devices and software that mix analog and digital techniques to allow communication, recall and storage of data.}
}
 
\newglossaryentry{FOSS}
{
    name=Free Open Source Software,
    description={Free Open Source Software: A method of developing software that does not charge for use of the software. The software's source code is also freely distributed, allowing users to modify their copy of the software or suggest changes to the organization developing it.}
}

\newglossaryentry{python}
{
    name=python,
    description={Python is an open source, interpreted, high-level, general-purpose programming language. It was initially released in the early 1990s, but has been continuously updated since then. Python 2 was the standard from 2000 to 2008, but in 2008 Python 3 was released with backwards-incompatible changes. This split the Python community, leading to Python 2 and Python 3 having slightly different versions of tools available. Python 2 continued to receive support and updates until 2020, when official support for Python ended (Wikipedia contributors, 2020). The open source nature of Python means that it is likely that Python 2 will continue to be updated by users after official support ends. }
}

% \newglossaryentry{OpenStreetMap}
% {
%     name=OpenStreetMap,
%     description={An open community of volunteers that maintain data about roads, trails, cafés, railway stations, and much more, all over the world.}
% }
\newglossaryentry{web framework}
{
    name=web framework,
    description={A heterogeneous set of software that allow a programmer to efficiently write and manage providing a service over the Internet. This could be a website or a mobile app (often it is both) or a go-between for other services. Examples include web2py and Django in Python or Phoenix in Elixir.}
}

\newglossaryentry{PostgreSQL}
{
   name=PostgreSQL,
   description={PostgreSQL is a powerful, open source object-relational database system with over 30 years of active development that has earned it a strong reputation for reliability, feature robustness, and performance.}
   % https://www.postgresql.org/
}

% https://en.wikipedia.org/wiki/MySQL
%  MySQL is a component of the LAMP web application software stack (and others), which is an acronym for Linux, Apache, MySQL, Perl/PHP/Python. MySQL is used by many database-driven web applications, including Drupal, Joomla, phpBB, and WordPress
\newglossaryentry{MySQL}
{
   name=MySQL,
   description={MySQL is an open-source relational database management system (RDBMS). Its name is a combination of "My", the name of co-founder Michael Widenius's daughter, and "SQL", the abbreviation for Structured Query Language}
}

% http://eden.sahanafoundation.org/wiki/WikiStart#WhatisSahanaEden
\newglossaryentry{EDEN}
{
   name=EDEN,
   description={The Emergency Development ENvironment, developed by the Sahana Foundation, is an Open Source Humanitarian Platform which can be used to provide solutions for Disaster Management, Development, and Environmental Management sectors}
}

\newglossaryentry{ICT4D}
{
   name=Information and Communication Technologies for Development,
   description={The movement to use digital technologies to serve the needs of the underprivileged and those living in the developing world. Criticized for being directed more at the developed worlds' love of technology than the actual needs of those it purports to serve. Also called digital humanitarianism}
}

% \newglossaryentry{capta}
% {
%    name=capta,
%    description={If data is every piece of information about an entity, capta are the semantically meaningfull elements within that data (Kitchin \& Dodge, 2011). The data of DNA is the entire sequence and the capta would be (we think) the genes that encode for particular traits and proteins}
% }

\newglossaryentry{srcd}
{
   name=source code,
   description={Human recognizable language, generally written in primaraly latin text in sets of files. Examples include C, Python (the language of EDEN), LaTeX (the language this paper is assembled by).}
}

\newglossaryentry{mscd}
{
   name=machine code,
   description={A language understood by a particular kind of computer chip. As \citet{Cramer2008-cw} notes, machine code is the only true "native" language to a particular computer. Can be generally understood as a list of specific instructions to the computer chip to perform operations: add two numbers, load a value into memory, write a value to disk or send a value over the internet. Common machine languages would be x86 (most laptops and desktops) and ARM (most phones).}
}

\newglossaryentry{sp}
{
    name=software project,
    description={Drawing from \citet{Mackenzie2006-hb}, this is the total social, material and organizational structure associated with the production, distribution and use of a particular piece of software. This includes the people who work directly on the source code of any \gls{sa} associated with the project as well as anyone who is part of the organization that manages, funds and directs the development of the software. It may also involve people who are not employed by the formal owner of the software project (this is especially true for open source developers). Any \glspl{sa} assembled by members of the project who are acting as members (and not on their own) are also part of the project. \glspl{sa} assembled using source code from the project are not part of the project per-se, but the software project bears some measure of responsibility for how those \glspl{sa} function and act in the world.}
}

\newglossaryentry{sa}
{
    name=software artifact,
    description={An entity of uncertain composition that behaves, for common users (as opposed to technical staff) as a single entity. A software-artifact could be a single binary with all its functionality provided by machine code included in that single location in memory. It could also be a binary that makes calls to various libraries. In the case of EDEN, it's an expensive set of Python files - some of which are human readable and some of which have been modified to make them faster to read. In this case a separate program, the Python binary itself, reads and executes the EDEN program. Even though EDEN is many separate files and contains no machine code, it is properly considered a software-artifact because users interact with it as a single entity.  Software-artifacts are produced periodically by software projects, but are not themselves entirely "software." The idea of software must be large enough to allow multiple software-artifacts to exist within the same project: the current version of your phone OS and the next version, the Facebook app on your phone and the web server that tells it what has happened. Nevertheless, when we are using "software" we are always directly interacting with one or more software-artifact(s). They are the material reality of software projects.}
}

\newglossaryentry{ap}
{
    name=assembly process,
    plural=assembly processes,
    description={All software must be assembled. In the simplest case this means the placing of machine code instructions, one after the other, in computer memory. In more complicated processes, this can include the translation from one or more programming language to the appropriate machine code, linking libraries together, retrieving source code from a remote location, and so on. This is rarely a manual processes, and is often done through one or more software artifacts. How a software artifact is assembled has an impact on the behavior of the artifact. Components can be placed in such a way that they do not function as expected, that their contribution to the artifact subverts expectations (an artifact might include a component designed for machine learning but only use its error formatting functionality) or in a way that makes functioning impossible. Assembly processes are often managed by a software project with the aim of producing their software artifact(s), but the process should not be considered a component of the artifact. It impacts the artifacts' structure, but isn't carried around in the artifact.}
}

\newglossaryentry{cmp}
{
  name=composite,
  description={Composites are fixed assemblies of more than one component which inherits the material qualities of its components, mediated through the structure which those components are assembled into. Once assembled, a composite can operate without human intervention. Composites are typified by extremely high complexity and extremely complex behavior, but once assembled their possible actions are set. They cannot be changed, only replaced. Each component of a composite may be an instruction or a datum, but they are generally composites themselves. Generally, each component makes a proportional contribution to the material qualities of the composite it is integrated into, but layers of assembly can place components in unexpected relationships with unforeseen outcomes. }
}

\newglossaryentry{webframework}
{
  name=Web Framework,
  description={A library (or set of libraries) that handles translation from and to the language of HTTP and other web technologies. The library of functionality they provide can range from wrapping basic text in a format a web browser will understand to providing functionality that allows users to log in, receive real-time messages and interact with the same web site from multiple clients simultaneously (Statz, 2010). Each Web framework also has its own philosophy about what information the developer is expected to provide and how much the developer needs to set. Some frameworks attempt to provide everything that is required to build almost any website, while others focus on providing a core of functionality and may not include support for connecting to a database or managing logins. Generally, any web framework may be used to make any website, but framework selection will dramatically change the experience of the software engineers developing that web site.}
}

\newglossaryentry{vm}
{
  name=Virtual Machine,
  description={A family of packaging techniques that allow packaging and distribution of an entire computing environment (operating system, libraries, programs) in a single digital object. This allows one physical computer to run several independent "machines" simultaneously. When a virtual machine is started, it the hardware it sees is virtual hardware simulated by the program "hosting" the virtual machine. The hosting program then translates requests to that virtual hardware into requests to the real hardware and relays the responses. Running a program in a virtual machine is slightly less efficient than running it on real hardware, but this cost is often less than the cost of manually arranging non-virtual installs on real machines.}
}

\newglossaryentry{sf}
{
  name=Sahana Foundation,
  description={The nonprofit that manages the EDEN project. Based in Los Angeles with an international scope and focuses on supporting communities in disaster preparedness and response through information technology.}
}

\newglossaryentry{w2p}
{
  name=web2py,
  description={An open source web framework for Python 2.7 and 3+.}
}

% \newglossaryentry{cmp}
% {
%   name=Composite,
%   description={A \citet{Latour1999-ui}ian black box whose functionality cannot be reduced to a blackbox containing other blackboxes. Instead, a composite is a network of blackboxes are heterogeneously linked. In addition, where the contents of a blackbox become socially visible when the blackbox stops working, composites can totally fail and remain opaque.}
% }


% \newglossaryentry{}
% {
%    name=,
%    description={}
% }

%      _______ _                                
%     / / ____| |                               
%    / / |  __| | ___  ___ ___  __ _ _ __ _   _ 
%   / /| | |_ | |/ _ \/ __/ __|/ _` | '__| | | |
%  / / | |__| | | (_) \__ \__ \ (_| | |  | |_| |
% /_/   \_____|_|\___/|___/___/\__,_|_|   \__, |
%                                          __/ |
%                                         |___/ 

% \loadglsentries{glossary}

\renewcommand{\bibsection}{\section}

%  ______          _               _            
% |  ____|        | |             | |           
% | |__ ___   ___ | |_ _ __   ___ | |_ ___  ___ 
% |  __/ _ \ / _ \| __| '_ \ / _ \| __/ _ \/ __|
% | | | (_) | (_) | |_| | | | (_) | ||  __/\__ \
% |_|  \___/ \___/ \__|_| |_|\___/ \__\___||___/
                                              
                                              

\sepfootnotecontent{boellactualvirtual}{\citet{Boellstorff2015-al} rejects the idea that events in digital spaces (like games or chat rooms) are any less "real" than things that exist in the physical world and thus rejects the common language of "real" and "virtual." He instead talks about "actual" (physical) spaces and "virtual" (within digital worlds) spaces. I will be describing the physical world as the "actual" world when appropriate and will talk about both virtual space (space that fully exist in computers such as Second Life and World of Warcraft) and digital space (spaces that are displayed though digital mediums, but are constituted of a mix of real and generated media [Facebook, Instagram]). It is all "real."}

\sepfootnotecontent{edensetup}{The Script I used can be found \url{http://eden.sahanafoundation.org/wiki/InstallationGuidelines/Linux/Server/CherokeePostgreSQL}, though as I describe, I often used different components. Unedited notes on the things I ran into can be found at \url{https://github.com/aeturnum/masters_project/blob/master/Notes/Web2Py_Notes}.}

\sepfootnotecontent{softwareupdates}{As \citet{Mackenzie2006-hb} points out, software is a process not a thing. This is especially true for software like \acrshort{eden}, which is made available to users over network connections. Pieces of software that stop receiving updates can quickly become vulnerable to new interactions with an ever-changing ecosystem. These vulnerabilities can result in programs becoming unstable, new security vulnerabilities, or simply an inability to keep up with the changes to other components. Software that is no longer being "maintained" (the phrase used to describe engineering work to patch security holes, update interfaces to modern standards, and make those updates generally available) can suddenly stop working because one or elements of its ecosystem cuts off old software. It is true that isolated software can run for years or decades without changes and that, for some systems, users never experience adverse consequences for leaving them frozen in time. However, whether or not a program can "safely" be left alone is highly dependent on external factors and software that seems "safe" from needing changes can suddenly and tragically need emergency updates at high cost \citep{Lee2020-rc}.}

\sepfootnotecontent{releaselanguage}{A language has evolved to speak about the relative stability of a particular \gls{sa} (or, more precisely, the boundary object that includes a \gls{sa} and its assembly instructions). Signaling about how often you will be changing your software allow users to choose the version of you work that will fit their own rhythm \citep{Canonical2017-gh}. 'Unstable' releases are often more likely to have bugs or be insecure, but also have new features that cutting-edge projects may need. 'Stable' releases have few new features but are well understood and unlikely to be the source of problems. }

\sepfootnotecontent{whatiseden}{It's a fair question to ask where \acrshort{eden} begins and ends. Certainly its source code is part of the program, but I would also include the collected documentation on how that source code should be deployed and supported as part of the "program," even thought it's not actively involved in the functioning of an assembled \gls{sa}. This is best understood with \citet{Star1989-uw}'s idea of boundary objects - coordinating objects that are able to play multiple roles for different actors. The \gls{sa} of \acrshort{eden} cannot exist for anyone outside of its immediate development team without distributing instructions on how to assemble the \gls{sa}, so I include that material in the \acrshort{eden} boundary object. It's worth noting that many of the requests for help with \acrshort{eden} on the \gls{sf} mailing list are questions not about \acrshort{eden} per-se, but about the tools and libraries that support a fully functioning \acrshort{eden}. In a very real sense, the \acrshort{eden} that exists without instructions on how to assemble it isn't available to me: I wouldn't know how to access it.}

\sepfootnotecontent{stablecaveat}{As of the writing of this paper, the versions of Ubuntu that \acrshort{eden} installs into by default have left long term support. Though evaluating if that's good or bad is outside the scope of this paper (and my expertise) it seems important to mention it.}

\sepfootnotecontent{updaterisk}{Of course, this update process also has risks. A well known mix of library versions will work together, but as I'll note later, mixing different versions of libraries can cause unexpected dysfunction. Suffice to say that the old versions of the tool and library ecosystem will generate the fewest unexpected tooling problems and maximize for developing in an environment familiar to the \acrshort{eden} team.}

\sepfootnotecontent{pythonversion}{I selected a release from the 3.6.X series because I'm fond of f-strings (a features added in 3.6 that allows compact formatting of printed information). However, 3.6.9 is now actually out of date, as 3.6.10 was released just a few days before the end of 2019 \citep{Python_Software_Foundation2019-iu}. In a perfect world I would have used 3.6.10, but as this project includes no private information I stuck to 3.6.9.}

\sepfootnotecontent{problemfix}{Interestingly enough, the problem was fixed by a piece of code written by a member of the \acrshort{eden} team \citep{Konig2019-fw}. The \gls{w2p} team had already noticed the problem and thought they had fixed it, but their fix did not work for for all circumstances and required more work.}

\sepfootnotecontent{dslnote}{'General purpose' programming languages are all Turing complete, which means they can fully describe the behavior of a 'Turing machine' - a theoretical automaton described by Alan Turing in the early 20th century. This means that all general purpose programming languages can be reduced to one another (a series of instructions generated by one language can be generated by another). However, there are also 'domain specific languages' that are designed to solve more specific problems that cannot be reduced to one another (and cannot fully describe the behavior of a Turing machine). Ironically, this document was typeset in \LaTeX, which is Turing complete.}

\sepfootnotecontent{socialcharacter}{I see a straight line between the historical social oddities of computer workers and the formation of the modern \acrshort{foss} movement. Having a space where computer people already understood themselves as being "special" (even if it was special in an pejorative way) would have also helped them imagine that different property systems were possible. The early history of Linux was fueled by the unusual legal position of AT\&T's Bell Labs (they were banned from making money off their work) which led to them taking few steps to protect their copyright and helping seed the open source movement \citep{Kelty2008-jm}.}

\sepfootnotecontent{compilelanguage}{The assembly process for a compiled language (and in fact for many languages that sit somewhere in the middle of the compiled-interpreted range) is generally executed by a \gls{sa} called a "compiler." I'm avoiding using the common word to avoid confusion in with the range of approaches in assembly.}

\sepfootnotecontent{staticlink}{Libraries do not have to exist outside of machine code. When a library is 'statically-linked' to a \gls{sa}, the section of the library's machine code that is used by the \gls{sa} is copied into the \gls{sa}'s machine code. So when the statically-linked assembled \gls{sa} calls the statically-linked library, the computer simply loads the section of the library that was copied into the \gls{sa} code. }

\sepfootnotecontent{sourcemodifications}{Modifications to the \acrshort{eden} source code are also common. I've modified the eden source code somewhat and it is, I would argue, still \acrshort{eden}. Where one draws the line is questionable and, I think, worth studying in its own right.}

\sepfootnotecontent{unofficialbinaries}{It is easy to example how someone might assemble an unofficial version of a piece of open source software like \acrshort{eden}. It may seem harder to imagine how the public gets access to an unofficial closed source piece of software that's distributed as machine code (like, say, the Facebook app). However, this situations are not as rare as you might expect. If you've ever owned a phone that is no longer receiving updates, or used a version of Windows that Microsoft no longer supports, every program in that environment is likely unofficial - because the companies no longer support that environment.}

\sepfootnotecontent{csblackbox}{Computer science draws on the general blackbox concept that Latour drew inspiration from to talk about acting on formal function definitions without knowing about how the function is implemented \citep[p. 33]{Abelson1996-fk}.}

\sepfootnotecontent{longquote}{Emphasis added by me. This quote mentions "regression-testing," which is worth briefly explaining. Regressions are when old, previously fixed problems reappear in new versions of the source code. This style of testing is in contrast to "test driven development," where tests are written as a description of what code should do \citep{Agile_Alliance2015-du}.}

\sepfootnotecontent{ethnographylimits}{It's here where I really miss an ethnographic component. A lot of my logic here is necessarily consequentialist based on my understanding of how software development works, but the logic the team is following could easily be deeper and more complicated than I imagine. Nevertheless I hope to draw conclusions that will be based on the material outcomes of their decisions and don't depend on the \acrshort{eden} project possessing a particular internal understanding.}

\sepfootnotecontent{working}{To be blunt, I find the common ideas of 'working' or 'broken' to not be that useful and suspect that a deeper literature review would have helped me to speak clearly on this question.}

\sepfootnotecontent{interpreted}{There is an important caveat to this claim for interpreted languages: their elements often can be replaced piecemeal. It would be simple to, for example, replace the file which was altered when I fixed my bug with another file. The rest of the \gls{sa} would remain untouched. Still, interpreted code is rarely updated piecemeal. The HTTP protocol, through which most javascript applications are distributed, does not have a way of updating cached (previously distributed) programs \citep{MDN_Contributors2020-bu}. It may be that using replacement instead of change distribution may have once been driven by technical concerns, but in the age of relatively inexpensive data and storage those concerns are gone. The reason to continue using replacement is cultural instead of technical. This is why, even though interpreted languages could distribute changes more easily than compiled languages, they use replacement.}

\sepfootnotecontent{runtimeimports}{It's worth expanding a little how this works. The \gls{python} \gls{sa} executes the python in the initial \gls{python} file provided. This could involve executing statements immediately or it could involve defining programmatic objects that may be invoked later. The 'import' statement is how, in \gls{python}, you note you want to include the result of executing another \gls{python} file. When a \gls{python} \gls{sa} encounters an import statement, it executes the associated file. This means that many \gls{python} programs have an initial import chain of stand-alone import statements. However, import statements can also be located in the programmatic objects that are defined for later use - and those objects will not be executed unless they are invoked elsewhere. So assembly is a somewhat fractured process with \Gls{python} and other interpreted languages.}

\sepfootnotecontent{pythonexeq}{When \Gls{python} import statements are causing new files to be read and executed by the interpreter, we are in a kind of mixed execution / assembly phase. The \Gls{python} is doing a mix of adding symbols to the symbol table (which other languages do during compilation) and executing program statements. If the \Gls{python} \gls{sa} were to fail to find an import or encounter a syntax error, that is an assembly error. If executing a program statement causes an error, it was not in assembly. This means that Python may translate some python statements to machine code, execute them, then fail when it reaches another assembly stage. I do not believe this is problematic for my work.}

\sepfootnotecontent{askingforhumaninput}{A \gls{sa} can be designed to seek input at any point, but this does not change the fact that humans cannot \textit{intercede and change} the actions the \gls{sa} will take. The list of actions the \gls{sa} takes may involve seeking human input, but the possible range of actions is already fixed. As \citet[p. 181-182]{Mackenzie2006-hb} points out, once agency is fixed in software, the software will reflect it in its execution. Any opportunity to "give feedback" to an assembled \gls{sa} will, at best, select another path from the possible paths fixed by assembly.}

\sepfootnotecontent{libversions}{The exact versions of the components may not be the ones stored in the canonical git repository. Each repository was at a particular git hash for this project. Eden was at 0718c0681bb58576a613e0edc4d4070ac214be21. web2py was at 93ef108c0b4b1c100622bf0002ec0972dec8be46. pydal was at cecd77127c122404c1aee7f6377c6a0150d86d84. yatl was at 5deb403a9e45f617588f02cd8f7682b3f98571b4. Some of these only exist in my fork of the respective repositories. }

\sepfootnotecontent{symbol}{In computer programming languages, a symbol a generic term for a saved value. The name comes from the practice in many languages of using a symbol table, which is an index of variable name to current value.} %todo: find source?

\sepfootnotecontent{moduledetails}{In order for a directly to be a well formed \Gls{python} module, it must contain a \Gls{python} file named \_\_init\_\_.py. This file may be empty, but may also execute \Gls{python} code. \_\_init\_\_ files are commonly used to make the elements of the library that are intended to be used by outsiders more easily accessible. For example, an \_\_init\_\_.py file in the \textit{example} module could contain the statement 'from .functions import run.' This would allow module users to type 'from example import run' instead of 'from example.functions import run.' This approach would allow \textit{example} users to know less about the internal details of \textit{example}.}

%      ________          _               _            
%     / /  ____|        | |             | |           
%    / /| |__ ___   ___ | |_ _ __   ___ | |_ ___  ___ 
%   / / |  __/ _ \ / _ \| __| '_ \ / _ \| __/ _ \/ __|
%  / /  | | | (_) | (_) | |_| | | | (_) | ||  __/\__ \
% /_/   |_|  \___/ \___/ \__|_| |_|\___/ \__\___||___/

% \title{Software: Gradually and Then Suddenly}
\title{Software as Composites: A Maze of Twisty Passages}
\shorttitle{Composites}
\author{Daniel "Drex" Drexler}
\affiliation{Center for Science, Technology and Society at Drexel University}
\date{April 2020}

\abstract{A study of software, the way it materializes perspectives, and the limits of the promulgations of those perspectives.}

\begin{document}
   \maketitle
   % single space toc
   \singlespacing
   \tableofcontents
   % back to double spacing
   \doublespacing
   % This is a progressive work that's trying to explain my situatedness
   \section{It's Software's World, We Just Live in it}
   \singlespacing
   \epigraph{[It] matters with which ways of living and dying we cast our lot}{\textit{\citet[p. 55]{Haraway2016-nc}}}
   \doublespacing
 

   Software is now well represented in every nook and cranny of the world. Though this project directly engages software, software was also used at every stage of its production: conception, composition, distribution and (in the age of covid-19) discussion. In the same moment that our reliance on software reaches ever loftier heights, we are surrounded by stories of important software projects being biased against vulnerable groups. Standpoint theory suggests that such biases often come from the hidden and unacknowledged perspectives of the people making software \citep{Harding1992-od,Haraway1988-nh}. In this sense, the problems caused by bias in software are not new problems. But, as \citet{Mackenzie2006-hb} and \citet{Kitchin2011-af} have noted, the management of a software project is filled with the work of managing relationships. Relationships between particular \glspl{sa} (both the current version and older releases), the humans working on the project and expectations about the future. Software also exists within ecosystems: code written for a particular software project is surrounded and supported by code that many other software projects rely upon. How a particular \gls{sa} impacts the world reflects the intent of both the organization that released this \gls{sa} and the diffuse intent of the surrounding software/hardware ecosystem. Software interventions into existing projects can highlight the paths of agency within \glspl{sa}. What can we learn about effecting change in software by studying how agency is mediated by the assembly process?

   \Glspl{sa} are the result of an assembly process that brings together the source code from many different software projects. Each \gls{sa} is what \citet{Latour1999-ui} called a "blackbox" - a container that hides complexity. But in order to properly describe software, I needed to expand the idea of a blackbox. In Latour's theory, each blackbox contains other blackboxes with clean separations between those layers \citep[p. 183]{Latour1999-ui}. Software blackboxes, however, often interact across blackbox boundaries. A \gls{sa} will use one library as a clean blackbox but interact directly with the inner-workings of another library. Exactly which pieces of code drive particular behaviors in a given software artifact is difficult to predict in advance and working backwards from artifact behavior to code identification is not straightforward. This be because a \gls{sa} is a \gls{cmp} - a heterogeneous mix of elements where the role of each element in any given \gls{sa} is determined by the rules of the particular assembly process used to create it and whose component parts cannot be broken apart. This means that users and developers experience things in fundamentally different ways. Where users are always interacting with \glspl{cmp}, whose various component pieces cannot be differentiated within the \gls{cmp}, developers are always interacting with pre-assembly components. This is because changing composites directly is inefficient, so modern software development process relies on making changes to  components before one or more assembly process(es). These components are where engineers leave imprints of their views. However, understanding how those views coe to the surface of \glspl{cmp} depends on examining the assembly process that creates each given \gls{cmp}.The path of each materialized perspective through various assembly processes is unique.

   Returning to the question of what one can do to address perspectives in software, this project takes the \acrfull{foss} project \acrfull{eden} as its object of study and site of intervention. I chose \acrshort{eden} because it is, as far as I can tell, a well-made piece of software that fulfills its role in the world. Others will engage socially problematic software and try to fix it, but the goal of my work here is to engage with a piece of software which is not obviously harmed by the standpoints of its developers. This does not aim to be a critical engagement, but an engagement whose successes and failures may be informative for future critical projects. The result of the modifications to \acrshort{eden} can be seen at <url>. The changes to \acrshort{eden} highlight where \acrshort{eden} crosses blackbox boundaries, though my efficacy in making those crossings apparent is limited to particular \textit{kinds} of boundaries. As we will discuss, software is deeply heterogeneous and that heterogeneity impacts the work that is needed to engage with it. 

% ===================================================
% =  _     _ _     ____            _                =
% = | |   (_) |_  |  _ \ _____   _(_) _____      __ =
% = | |   | | __| | |_) / _ \ \ / / |/ _ \ \ /\ / / =
% = | |___| | |_  |  _ <  __/\ V /| |  __/\ V  V /  =
% = |_____|_|\__| |_| \_\___| \_/ |_|\___| \_/\_/   =
% ===================================================

   % \section{How I Think About Software}

   % Modern Software Production
  % Sources in this section:
  % Mackenzie, A. Cutting Code: Software and Sociality. Edited by Steve Jones. Peter Lang Publishing, 2006.
  %   - relationality of software
  %   - the process of creating software is a process of managing relationships: with the future, with the past, with other software
  
  % Bivens, Rena. “The Gender Binary Will Not Be Deprogrammed: Ten Years of Coding Gender on Facebook.” New Media & Society 19, no. 6 (June 1, 2017): 880–98.
  % Elish, Madeleine Clare. “Moral Crumple Zones: Cautionary Tales in Human-Robot Interaction.” Engaging Science, Technology, and Society 5, no. 0 (March 23, 2019): 40–60.
  
  % ...?
  \section{Software: a Thing and a Process}
  \singlespacing
  \epigraph{I have passed through a membrane where the real world and its uses no longer matter. I am a software engineer[.]"}{\textit{\citet[p. 3]{Ullman2012-fq}}}
  \doublespacing
  
  It is difficult to talk with precision about what software 'is.' Individual programs that have been written in (or translated into) machine code are software (I will be calling these '\glspl{sa}'). Networks of \glspl{sa} which only function when connected (such as the combination of one or more Facebook apps and the Facebook servers) also are clearly software. There are also software projects like the IETF Task Force that produce no \glspl{sa} at all, but create and manage standards that are essential for the interoperability of software. The field is diverse and engaging with it demands some definitional boundaries.
   
  \citet{Mackenzie2006-hb} focuses on understanding how 'software projects' function. The \glspl{sa} produced by (or associated with) a given project, the people who work for the organization that owns the project, and imaginaries  about the future or the purpose of the project are all part of Mackenzie's definition. A software project is made of individual artifacts (both software and others) and relationships. This means including both the particular qualities of each \gls{sa} (how does the current version of a program work and how the next one \textit{will} work) as well as the relationships between each \gls{sa} (how the current version will give way [or not] to the next version) in software. It also means that software is the thinking, planning, and imagining about how the project will: work, relate to the world, and relate to other \glspl{sa} and projects \citep{Mackenzie2006-hb}. Software is both material and socially defined. 

  The qualities that exist within a particular \gls{sa}, were first imagined by engineers (much like \citet{Fleck2012-qr}'s thought collective) that work on that \gls{sa}'s software project or one of the supporting projects. The pipeline between how we imagine software will be in the future and the work of creating software that behaves like we imagine it should is important. It means that examining the details of how software works will tell us about how people imagined it would work.


  % Social footprint of software and digital cultures
  % Sources in this section:
  % Boellstorff, Tom. “The Opportunity to Contribute: Disability and the Digital Entrepreneur.” Information, Communication and Society 22, no. 4 (March 21, 2019): 474–90.
  %   - pushing back against reducing the social to the commercial -or- a higlighting of the social character of commercial work
  % Humphreys, Lee. The Qualified Self: Social Media and the Accounting of Everyday Life. MIT Press, 2018.
  %   - use of digital medium to demonstrate qualificiations
  %   - NOT SURE I'LL USE
  % Jurgenson, Nathan. The Social Photo: On Photography and Social Media. Verso Books, 2019.
  %   - use of media to transmit social qualities
  %   - structural nature of the world as mediated by software giving rise to particular kinds of expression and communication
  
  % todo?:
  % Tiidenberg, Katrin, ed. Selfies: Why We Love (and Hate) Them. Emerald Publishing Limited, 2018.
  %   - more on using media to communicate meaning
  %   - new forms of media facing hostility
  \subsection{The Material Character of Software}
  The material and social characteristics of software are co-constitutive its impact on the world. As Facebook attempted to respond the changing social situation around gender, they faced a back-and-forth between what was technically possible and generally allowed. They eventually settled on a solution that allowed lacuna to exist in the database in return for a more socially acceptable list of gender options \citep{Bivens2017-tc}. Softwares flexibility means that nearly any situation can be represented and recorded, but each new piece of software is built on top of an ecosystem which makes certain things easy and other things hard. The database practices Facebook relied on in their early days represented gender as a binary value - a choice which later made it impossible to both offer non-binary genders and have a value in the gender field of the database.

  Sociological work on new media supports the idea that there is something unique about how software impacts the world. Many of the ways we socialize through software have pre-digital antecedents, but the unique power of software to create new experiences is clearly visible. You do not have to be making software to feel the power \textit{of} software to structure and channel your life. We are both using media in was that are only possible through digital systems and using digital media to account for ourselves in new ways and to new audiences \citep{Humphreys2018-ge,Jurgenson2019-tl}. Though we have always been different things to different people, it is only through software that we can be interacting with people who treat us as if we are famous and as if we are totally unknown simultaneously \citep{Dean2010-lk}. The important thing to understand is that these new social realities reflect the new material force of software being brought to bear on society. These new bottles contain old wine, but it turns out that the bottle makes a huge difference to how we experience the wine. It isn't necessary for software to be attempting to transform the structure of society, its material force drives social transformation even when that transformation isn't imagined by its creators. 


  % Social organizations around software
  % Sources in this section:   
  %   - legitimacy of doing anthropoligical work in purely digital spaces, actual v.s. virtual - all real
  % Cox, Geoff, and Christopher Alex McLean. Speaking Code: Coding as Aesthetic and Political Expression. MIT Press, 2013.
  %   - Background on software studies
  %   - Code as speech but *not* software as speech
  %   - Involves software, but as seen through the act of "coding"
  % Ensmenger, Nathan L. The Computer Boys Take Over: Computers, Programmers, and the Politics of Technical Expertise. MIT Press, 2012.
  %   - Social history of programming and selecting programmers
  %   - More about the particular social and historical shape of programming and programmers
  %   - background for ethnographic work
  % Gabriella Coleman, E. Coding Freedom: The Ethics and Aesthetics of Hacking. Princeton University Press, 2012.
  %   - social idea of hacking and of freedom
  %   - ways of experiencing freedom within software and software groups
  % Kelty, Christopher M. Two Bits: The Cultural Significance of Free Software. Duke University Press, 2008.
  %   - rules of FOSS give rise to certain consistent social rules
  \subsection{Software Cultures are Cultures of Materiality}

  Ethnographic work on communities that are deeply involved with software support the idea that the material qualities of software uniquely and meaningfully impact those who work on it. When \citet{Kelty2008-jm} argues that the open culture of digital spaces follows from the commitment to sharing, he is also suggesting a strong linkage between the material character of technology and the social goals of its builders. It would be possible to build software \textit{wrong} and undermine the \gls{foss} movements' goals \citep{Kelty2008-jm}. His work underlines the importance of understanding the material qualities of software while it largely leaves them untouched.

  The history of computers and computer work speaks to the material demands of software and the way that those material characteristics drive social factors. Computer workers gained their reputation for keeping odd hours and existing outside or alongside the traditional power hierarchy because they needed to do work on mainframe computers when those computers weren't doing business calculations \citep{Ensmenger2012-kz}. The particular materiality of computers at that time (that they were singular and could only run one task at a time) gave rise to social characteristics have have somewhat endured to today\sepfootnote{socialcharacter}. When \citet{Cox2013-zo} investigated the connections between speech and code, the material force of software was central to the connection. One reason code is special is that it is speech that can be mechanistically executed as well as being the content of a traditional speech-act. 

  There are even pre-computer arguments for seeing computer software as having unusual and deeply important material realities. Hacking is a cultural movement that began before software and which is focused on joyful play in eliding and subverting the intended purpose of objects \citep{Drexler2019-ja,Gabriella_Coleman2012-lq}. That hacking has become so associated with digital technology testifies both to the power of the act and the complexity of the task. Hackers enjoy hacking on software because the medium is difficult and demanding. They can make a career out if it because of the enormous material impact of changing software from working \textit{this way} to \text{that way}.

  % Situated knowledges and translation review
   % Said, Edward W. Orientalism. Vintage Books, 1979.
   % pre-
   % Latour, Bruno. “Give Me a Laboratory and I Will Raise the World. En Science Observed: Perspectives on the Social Study of Science (pp. 141-170).” Beverly Hills: Sage Publications, 1983.
   % skip maybe?
   % Haraway, Donna. “Situated Knowledges: The Science Question in Feminism and the Privilege of Partial Perspective.” Feminist Studies: FS 14, no. 3 (1988): 575–99.
   % Harding, Sandra. “Rethinking Standpoint Epistemology: What Is‘ Strong Objectivity?’” The Centennial Review 36, no. 3 (1992): 437–70.
   % Haraway, Donna. “Situated Knowledges: The Science Question in Feminism and the Privilege of Partial Perspective.” Feminist Studies: FS 14, no. 3 (1988): 575–99.
   % Harraway, Donna. “Modest_Witness@Second_Millennium.FemaleMan©_Meets_OncoMouseTM.” Routledge New York, 1997.
   % Fleck, Ludwik. Genesis and Development of a Scientific Fact. University of Chicago Press, 2012.
   % Subramaniam, Banu. Ghost Stories for Darwin: The Science of Variation and the Politics of Diversity. University of Illinois Press, 2014.
   % Traweek, Sharon. Beamtimes and Lifetimes. Harvard University Press, 2009.
  %   - cultural charaters of teams show up in the tools that they build to do their work
   % Eubanks, Virginia. Automating Inequality: How High-Tech Tools Profile, Police, and Punish the Poor. St. Martin’s Press, 2018.
  %   - materialization of human perspectives in computer algorithms
  %   - questioning the projection of agency onto computer code v.s. understanding computer code as "doing the work" of humans
  %   - more examples of tools containing material standpoints (specifically the eugenical quality of population statistics)
   \subsection{Materialized Perspectives}
   \singlespacing
   \epigraph{A model is worked, and it does work}{\textit{\citet[p. 63]{Haraway2016-nc}}}
   \doublespacing

   My account of the pluripotency of software and its particular material impacts begs a question of the nature of software: how much of its impact is intended and how much of its impact is caused by bias within the software? Software is basically epistemic - it functions through selecting and acting on understandings of the world. Understanding bias and developing language around bias is a well-studied area in its own right. Bias can persist in knowledge and practice in a peripheral way (\citet{Fleck2012-qr} describes how syphilis retains a moral dimension even when it is understood to be a microbe) or in a way that determines the entire structure of thought on a subject (such as \citet{Said1979-jw}'s deconstruction of orientalism). 

   The theoretical framework I find most useful here is \citet{Harding1992-od} and \citet{Haraway1988-nh}'s "standpoint theory." Specifically I'm interested in the connection (or lack of connection) between choosing one way of knowing or doing within software over another way of knowing or doing. When one does this without acknowledging the choice or connecting it to a wider world-view, it's what \citet{Haraway1988-nh} calls a god trick: the appearance of knowledge simply \textit{being}, as if it came from nowhere and is not touched by the life background of the person who created it. God tricks are central to systems which embed unacknowledged standpoints within them. These systems can begin problematic, like how early biometric techniques tend to split populations into groups because they were built with a eugenic frame of reference \citet{Subramaniam2014-wg}. They can also accidentally become problematic, like how the fetishistic focus on the gene led us to over-invest in technologies that could not, on their own, provide us with new ways to affect the network of genetic and biological action that we call life \citet{Harraway1997-va,Reardon2017-bo}. Problematic characters of systems are allowed to stay hidden because the problematic qualities are not problematic for those who created the systems. 

   It is not necessary for a system to become problematic before it's useful to investigate standpoints encoded into it. Software, like any other tool, exists to help save human effort. In relieving humans from action, tools must trigger outcomes that might otherwise be proceeded by human choice. The number and nature of choices that can be elided within tools have only grown more diverse with time. The real world work of finding and addressing standpoints in problematic software can be assisted by finding and addressing standpoints that are not themselves problematic. When \citet{Traweek2009-uu} studied high energy physicists, her observation that the particle detectors built by different teams had characteristics that flowed from those teams' personalities and preferences did not need to be used to repair a flow to be useful. This project is interested in finding choices that software makes but does not acknowledge. These latter day god tricks escape from documentation or acknowledgment. They can be deeply aligned with their creators' world view and be difficult to describe to insiders. A great deal could be learned by engaging with the engineers who create these materialized standpoints, but we don't need to speak to them in order to point out what is there.
,
  
  % Cheney-Lippold, John. We Are Data: Algorithms and the Making of Our Digital Selves. NYU Press, 2018.
  % todo: 
  % Boellstorff, Tom. Coming of Age in Second Life: An Anthropologist Explores the Virtually Human. Princeton University Press, 2015.
  \subsection{Software Without Ethnography}
  \singlespacing
  \epigraph{[T]he "writing of technology" is by by no means universal; the opaque and stubborn places do not lie simply beneath technology, but are wrapped around and in it}{\textit{\citet[p. 181]{Mackenzie2006-hb}}}
  \doublespacing

  The bulk of sociological work around software has been work that with the material effect of software through its impact on social worlds. This project does not do that. It is conducted with the assumption that omitting social engagement will limit, rather than eliminating, the usefulness of the project. This belief is based on the studies of social outcomes that suggest that software possess a strong material character outside of social construction \citep{Dean2010-lk,Eubanks2018-hc,Humphreys2018-ge,Kelty2008-jm}. It is also based on work that show that once social information has passed into digital systems, that information will be manipulated and used in ways that can be driven as much by the quirks of digital systems as by social goals \citep{Cheney-Lippold2018-lw}. This project, I believe, points towards a future project that engages more deeply in the social worlds of the makers and users of \acrshort{eden}. Doing so would allow us to understand how \acrshort{eden} constructs space for its makers, its users and the world in general \citep{Kitchin2011-af}. 

  Better understanding the nature of software isolated from social situations will enable more complex work that studies both. It is those qualities of the digital world, what is found when you "pass through a membrane where the real world" no longer matters, that this project is interested in finding \citep[p. 3]{Ullman2012-fq}.

  % Kitchin, Rob, and Martin Dodge. Code/space: Software and Everyday Life. MIT Press, 2011.
  %   - power of code / software in social space
  %   - creation of spaces through software
  % Cramer, Florian, and Matthew Fuller. “INTERFACE.” In Software Studies: A Lexicon, edited by Matthew Fuller, 149–53. MIT Press, 2008.
  % Yuill, Simon. “INTERRUPT.” In Software Studies: A Lexicon, edited by Matthew Fuller, 161–68. MIT Press, 2008.
  % Cramer, Florian. “LANGUAGE.” In Software Studies: A Lexicon, edited by Matthew Fuller, 168–74. MIT Press, 2008.
  % Crutzen, Cecile, and Erna Kotkamp. “OBJECT ORIENTATION.” In Software Studies: A Lexicon, edited by Matthew Fuller, 200–207. MIT Press, 2008.  
  \subsection{Yes, but what IS Software?}

  Work on the powerful impact of software on our social world (and the power impact of our social world on software) somewhat elides the central question of my work: what \textit{is} software? What are the qualities of this thing and this practice that has transformed our world, often on accident? \citet{Cramer2008-cw} focused on the Janus-like qualities of computer languages - forced to fulfill the needs of humans and machines. While \citet{Cramer2008-cw} notes that the only actual computer language are the machine languages spoken by computer chips, he also points out that the primary concern of general purpose 'computer'\sepfootnote{dslnote} languages (including \gls{python}) is attending to different human priorities. This is especially true because all general purpose languages can be reduced to one another, so any difference in functionality come only from the difference in how well the language suits the preferences of the human writing it. \citet{Yuill2008-by} talks about the character of the ecosystem of programs and the centrality of "interrupts" to modern system design. Most software written today is written with the expectation that it may be interrupted. This is because modern computers remain responsive to people (and other \glspl{sa} running on the computer) by being ready to interrupt any process at any moment. This is important because it prepares software to try to deal with the unexpected.

  I find \citet{Latour1999-ui}'s blackboxes a good start\sepfootnote{csblackbox} for talking about software and how it functions in the world. Blackboxes are enclosed units that accomplish a task without exposing outsiders to the interior details of how it works. Like software, blackboxes can contain almost anything with any level of complexity, but to those outside the box it appears singular and cohesive. It's only in failure that blackboxes are differentiated from other objects. Latour was interested in how, once a blackbox failed, the fact that it has components becomes socially available and socially unavoidable. Often, blackboxes contain other black boxes, each one waiting for failure to make the fact that it has internal components. Software too, has important internal components that are invisible. However, because the tools and skills needed to disassemble software are so much rarer than the skills and tools to disassemble, in Latour's example, a projector there are important differences in how software is perceived socially. 

  % todo: software artifacts


  % Intervention
  % Zuiderent-Jerak, Teun. Situated Intervention: Sociological Experiments in Health Care. MIT Press, 2015.
  % Sismondo, Sergio. “Science and Technology Studies and an Engaged Program.” The Handbook of Science and Technology Studies 3 (2008): 13–32.
  
  
  \subsection{Taking Action}
  \singlespacing
  \epigraph{We live in capitalism, its power seems inescapable – but then, so did the divine right of kings. Any human power can be resisted and changed by human beings.}{\textit{\citet{Le_Guin2014-ue}}}
  \doublespacing
  
  So in one hand I hold \citet{Latour1999-ui}'s blackboxes and in the other \citet{Harding1992-od} and \citet{Haraway1988-nh}'s situated knowledges. As \citet{Mackenzie2006-hb} recounts, the process that produces software is complex and heterogeneous. It defies simple analysis and it, itself, a deeply social thing that will also produce \glspl{sa} that can be mechanistically executed \citep{Cox2013-zo}. Yet we are beset on all sides with software whose bias is plain for all the world to see \citep{Bivens2017-tc,Dean2010-lk,Elish2019-ls,Eubanks2018-hc,Schull2012-nc}. How can our academic theories be used to address these practical concerns? How can we find what \citet{Sismondo2008-xz} called an "engaged program," which combines theory and contact with the real world?

  The first step to to try doing real work on real software. \citet{Zuiderent-Jerak2015-go}'s \textit{Situated Intervention} (which also draws from situated knowledges) argues forcefully that social scientists can and must intervene to learn. He describes how medical professionals use interventions (and their outcomes) as tools to generate knowledge and test assumptions. My own pre-academic experience as a software engineer supports the knowledge generating power of careful and measured intervention. This project hopes that it can find materialized perspectives within a wholly unobjectionable software project (and its associated \glspl{sa}) and, though engaging with the source code of that software project, learn something about how we might address materialized bias in more convoluted situations.

% =======================================
% =  __  __      _   _               _  =
% = |  \/  | ___| |_| |__   ___   __| | =
% = | |\/| |/ _ \ __| '_ \ / _ \ / _` | =
% = | |  | |  __/ |_| | | | (_) | (_| | =
% = |_|  |_|\___|\__|_| |_|\___/ \__,_| =
% =======================================



  \section{The object of study}
  \subsection{Software in General}
  Before diving in, I should define some language. Some of this language will be drawn from existing literature and some of it will simply be me drawing boundaries around the sometimes fuzzy concepts that can be involved with software. I will be developing these ideas throughout the paper and some of them exist in an updated form in the glossary.

  A \textbf{\gls{sa}} is any arrangement of machine code, scripts, configuration files, network connections, or other constitutive resources that can be executed by a computer. A collection of such resources become a software artifact as soon as the computer can be passed the bundle of elements and follow the instructions encoded within the artifact. This form of software is important because it is in this form that software is distributed.

  A \textbf{\gls{sp}} is, as \citet{Mackenzie2006-hb} defines it, the extended social, material and organizational structure that produces "software." These projects are not unified by the production of software per-se, but by hoping to change how software functions or how it impacts the world (in a \citet{Kitchin2011-af} sort of way). Though software projects may produce \glspl{sa}, they do not have to. Technical organizations that create standards that other software projects might follow are also software projects. The same is true for professional organizations that aim to shape the culture of software production. 

  Throughout this paper I will speak about the intent or actions of a \gls{sp}. This is not an attempt to say that the \gls{sp} totally controls the actions of individuals involved with it, but a recognition that the social conditions inside a \gls{sp} are expressed through individual members of that \gls{sp} taking action. Each individual person has their own explanation for why they acted in their particular way, but we can still usefully speak about the general opinion, actions and intents of the general project.

  Finally, an \textbf{\gls{ap}} is the arranging of elements of a \gls{sa} in such a way that the computer can execute them. Such a process always happens (even if it is just placing machine language instructions sequentially in memory) before the computer can execute the \gls{sa}. This process is often carried out by one or more \gls{sa}(s). Sometimes these \glspl{sa} are part of the software project making the \gls{sa}, sometimes the are tools shared between many software projects (generally with configuration supplied by this particular project).

% =====================================================
% =  ____  _ _          _______ ____  _____ _   ___   =
% = / ___|(_) |_ ___   / / ____|  _ \| ____| \ | \ \  =
% = \___ \| | __/ _ \ | ||  _| | | | |  _| |  \| || | =
% =  ___) | | ||  __/ | || |___| |_| | |___| |\  || | =
% = |____/|_|\__\___| | ||_____|____/|_____|_| \_|| | =
% =                    \_\                       /_/  =
% =====================================================

  \subsection{EDEN}
  \singlespacing
  \epigraph{That virtual worlds are places means they can be fieldsites;}{\textit{\citet[p. 107]{Boellstorff2015-al}}}
  \doublespacing

   The particular piece of software this project studies is \acrlong{eden}. \acrshort{eden} was originally created by a coalition of Sri Lankan \acrlong{ict} companies in the wake of the 2004 Indian Ocean Earthquake and Tsunami. The project is now managed by the nonprofit \gls{sf}. It has been used in numerous disaster responses since 2004 and is also used by a number of organizations for managing resources outside of any specific disaster \citep{Sahana_Foundation_undated-hl}. \acrshort{eden}'s functionality can fairly be described as tracking and managing resources. Its power comes from the enormous range and detail of the information it knows how to track. \acrshort{eden} has indexes for organizations, people, projects, events, facilities, supplies, documents, possible scenarios, and events. It also provides on-platform messaging and special tools for the management of emergency shelters \citep{Sahana_Foundation2011-od}. Each resource is meant to be connected to other resources: people work for organizations, projects are run by organizations and are associated with people, facilities are linked with projects and organizations and other resources like supplies and verticals. The flexibility of the software means that it can be used to manage a single organization, multiple organization, or used as a hub for many different groups coordinating around shared goals but without central authority. The system aims to be as comprehensive as possible and to use the same entity for resource and system management. The entries for people can act as a simple rolodex and will also double, if desired, as that person's account within \acrshort{eden}. The interface for managing goods is the same interface for managing access to the management system. To the degree possible, \acrshort{eden} is structured to allow the same people who do the day-to-day work of the organization to administer the system that manages the organizations' resources. It also aims to be an effective tool for people at all levels: administrators can track where people and supplies are allocated and volunteers can access their assignments, documents and information about how to use resources.
   % \includegraphics{images/EDEN_diagram.png}
   

   \subsection{Why EDEN}
   I selected \acrshort{eden} for this project for two primary reasons: it is a \acrlong{foss} software project in a language I am familiar with and it is not obviously problematic. I will detail its open source pedigree shortly, but first I want to explain my second selection criteria. "Improving" software (whatever improving means) can usefully be separated into at least two questions: what quality should change and how do you bring that change about? This project attempts only to speak about the second (likely easier) question. Partially this is because the project was designed to fit within the confines of a final project for a masters degree. This project represents, roughly, three graduate level classes worth of work. I didn't feel like I had time to find \textit{and} fix flaws. So this project should be understood as neutral on the question of, "is \acrshort{eden} good?" Nothing about \acrshort{eden} seems bad to me. They have received numerous awards, glowing testimonials, and are used by many large organizations that could use other products if \acrshort{eden} were lacking. 

   I lack the experience and expertise to say that I think \acrshort{eden} is \textit{good}. Assessing if software is "good" or "bad" is not straightforward. Simply examining \glspl{sa} in isolation tell us very little. It's only through engaging with one or more \gls{sa}(s) as they exist in the lived world and contextualizing that with detailed ethnographic work that it's possible to start making value judgments \citep{Eubanks2018-hc,Schull2012-nc}. Those judgments wouldn't be universal, of course, but would be about a particular population. So this paper is done from the perspective that \acrshort{eden} seems fine to me. The project is interested in the technical details of how the \acrshort{eden} \gls{sa} emerges out of its \gls{sp} and how agency is modified by that process. 

   Finally, and briefly, this project does not take the position that the technical qualities it investigates are free from the impact of social structures. \citet{Gabriella_Coleman2012-lq} and \citet{Kelty2008-jm} have both compellingly shown that the social and technical co-produce each other. However, we can still usefully speak about qualities that technical systems have and how those qualities impact our lived experience. That this project has obvious extensions in the social and ethnographic realm is a strength and declining to investigate them should be understood as a concession to time.

   \subsection{Out of Many, One}
   Wherever possible, \acrshort{eden} uses \acrshort{foss} technologies. The language it is written in, the libraries it relies on to provide functionality, the tools it uses to support its functionality, and its main operating system are all both open source and available at no cost. \acrshort{eden} will generally operate on top of non-\acrshort{foss} systems like Microsoft Windows, but the team doesn't prioritize systems outside of the \acrshort{foss} systems they develop and test on \citep{Sahana_Foundation2015-zs}. \citet{Kelty2008-jm} talks about how \acrshort{foss} is both a philosophy and a system of development that has practical impacts. One of the side effects of \acrshort{eden} committing to use the \acrshort{foss} ecosystem is it makes my form of engagement possible. Though it is possible to examine compiled machine code and draw some conclusions about the intent and process that assembled it, such a project would be far outside my capabilities. Instead, the source code of \acrshort{eden}, web2py (the \gls{web framework} \acrshort{eden} uses), Python (the language \acrshort{eden} and web2py are written in) and all of the libraries used by the project are open source. Their preferred databases (MySql or PostgreSQL) are also fully open source projects. Open source projects often don't just publish the current source code, but offer full histories of what change, when it changed, who changed it and how it was changed. These changes often include notes about why \textit{that particular} change was made over any other possible change \citep[p. 13-16]{Chacon2014-im}. Open source projects also commonly have systems for tracking lists of unfixed flaws as well as planned future improvements (both types of \citet{Mackenzie2006-hb} relationships), but those systems operate above the layer of source code so this project does not engage with them.

  \subsection{Enumerating The Specifics of my Engagement}
  % much thanks to https://www.tablesgenerator.com/#
  \Acrshort{eden} has a large number of individual components. Executing a fully assembled \acrshort{eden} \gls{sa} would involve a number of \Gls{python} libraries, a number of other \glspl{sa} (a database, various compiled libraries) and a large amount of non-python code (such as the javascript contained in the \acrshort{eden} repository). Engaging all of this code is certainly possible if given enough time, but did not seem possible given the constraints of a masters project. So, I have chosen to focus on the \Gls{python} portions of a limit set of the libraries used by \acrshort{eden}. These libraries are listed in Table \ref{tab:table-1}\sepfootnote{libversions}. 

  \begin{table}[ht]
  \caption{Purpose of libraries}
  \label{tab:table-1}
  % https://stackoverflow.com/questions/2895780/how-to-code-tables-with-multi-line-cells
  \begin{tabular}{|l|p{.65\textwidth}|}
  \hline
  Component Name & Brief Description of Functionality                                                 \\ \hline
  Eden           & Implements the logic for managing the various resources Eden manages               \\ \hline
  web2py         & Provides interfaces to easily provide web services over HTTP and related protocols \\ \hline
  pydal          & Library for interacting with a database using Python objects instead of raw text   \\ \hline
  yatl           & Library for generating HTML content through templates                              \\ \hline
  \end{tabular}
% This MUST be at the start of the line without spaces before it or it will cause an error
% https://tex.stackexchange.com/questions/62278/problems-with-endfloat-package
\end{table}
  
  My choice to focus on these components in particular does not come from a considered opinion that these four components are the most important components. That judgment would require a good deal more work than I have done to develop an opinion about how to compare functionality across programming language boundaries. For the same reason, my analysis omits all non-programmatic components (databases, static content, etc). This omission should also be understood as a limitation imposed by time as opposed to a considered opinion that those components contribute less to the behavior of a \gls{sa}. 

  Instead, I chose these components because they were the ones I interacted with most during my investigation of the \acrshort{eden} project. There are also formal links between the projects: the \acrshort{eden} project identifies web2py as its \gls{webframework} and web2py identifies both pdal (as DAL) and yatl components of itself \citep{Di_Pierro2020-wn,Sahana_Foundation_undated-ww}. There are other primary components of the \acrshort{eden} project, but many of them are in other languages or are themselves \glspl{sa} (such as databases).

  It's foreseeable that my conclusions, focused on these four components, might not extend to the entire \gls{sa} / project, but I doubt it. In almost all circumstances, the components that most impacts what the \gls{sa} does would likely be in the \acrshort{eden} source code. That does not mean, as I will show, that most of the code that is associated with a particular element of an \acrshort{eden} \gls{sa} is within the \acrshort{eden} source code. It may be useful to refer to the size (in lines of code) of the various libraries to get a rough sense of the relative size of each one (See \ref{tab:table-2}). 

  \begin{table}[ht]
  \caption{Size of Libraries}
  \label{tab:table-2}
  \begin{tabular}{|l|c|c|}
  \hline
  Component Name & Lines of Python Code & Lines of Non-python Code \\ \hline
  Eden           & 469,117              & 793,661                  \\ \hline
  web2py         & 103,593              & 41,793                   \\ \hline
  pydal          & 24,518               & 416                      \\ \hline
  yatl           & 1.131                & 69                       \\ \hline
  \end{tabular}
\end{table}

  In general, the number of lines of code in a piece of software will correspond to that programs capabilities. Lines of code can also be used to roughly compare the relative contributions of components, especially when all components are written in the same language. It's possible to write lines of code that have no meaningful impact and it's easy to imagine scenarios where single lines of code make thousands meaningless (by turning off a feature, for instance), but there is no reason to believe these instances would happen more or less often in any particular component. Similarly -  it is much easier to imagine accomplishing the work done in fifteen lines of code with ten different lines, but it is much harder to imagine doing the work of fifteen hundred lines of code in a thousand. Efficient code is efficient, but there is a limit.

% ====================================
% =  ____                 _ _        =
% = |  _ \ ___  ___ _   _| | |_ ___  =
% = | |_) / _ \/ __| | | | | __/ __| =
% = |  _ <  __/\__ \ |_| | | |_\__ \ =
% = |_| \_\___||___/\__,_|_|\__|___/ =
% ====================================

  \section{Investigating EDEN}
   My work began, as all software work does, with work of assembling the components that transform \acrshort{eden} from a collection of \gls{python} source files into a \gls{sa}. This requires connecting a number of components together: libraries and tools in the \Gls{python} language and a wider set of heterogeneous tools (databases, non-\gls{python} libraries and tools). Some of these components remain as source code to be interpreted by \gls{python}, some of them are downloaded as source code and go through their own assembly process to generate their own \glspl{sa}. The assembly process that draws the components of \acrshort{eden} together does not happen in a single step, but is a number of loosely ordered heterogeneous processes. Some must be completed before others and there is an officially recommended order in which to prepare the various components, but often these orders are more matters of preference than necessity. What is important is that all of the required components are collected in their expected places by the time \acrshort{eden} itself is run. 

   The \gls{sf} recommends that developers use a \gls{vm} that has \acrshort{eden} and its supporting libraries installed through a script. However, at the time that I engaged with the project, the instructions for how to install \acrshort{eden} focused on using operating systems and \gls{python} versions that have since stopped being updated\sepfootnote{softwareupdates}. Though more modern scripts can be found, the standard install scripts for the \acrshort{eden} \gls{vm} and the script to install the software on a physical machine both use operating systems released in the mid-2010s that have not been maintained for at least 5 years \citep{Canonical2020-ru}. However, \acrshort{eden} is aware that this is problematic and makes an effort to support newer versions of \gls{python} and newer operating systems, but official instructions to use the latest software are sparse.

   \subsection{Approaches to Tooling}
   Choosing to offer a fixed and unusually old set of tools is the first materialized I found encoded into \acrshort{eden}\sepfootnote{whatiseden}. The state of the scripts reflect a culturally important choice. The team could note and situate their approach in their documentation, but they have not. However, project-wise choices to use older or newer versions of tools are common. There are software projects (sometimes entire programming languages) that greatly value using the most up to date version of a tool or library \citep{Fernandes_da_Costa2017-mh}. These communities have legitimate fear that older versions of tools are examined less often and will likely be fixed less frequently. They feel that using the latest (within reason) version is a goodness in of itself\sepfootnote{releaselanguage}. If the \acrshort{eden} team followed this philosophy, they would not default to using older operating systems and versions of \gls{python}. They would need to watch their ecosystem of tools and libraries more closely, but the versions they were watching would also be more in the collective consciousness of the \acrshort{foss} world. 

   All this isn't to say that the \acrshort{eden} team choice isn't a sensible one. The latest versions of tools often lose track of the world outside the top of the capitalist pyramid. The same networks of power that structure the spread of physical technology also shape the attention of active software engineers. \acrshort{eden} has chosen to use established and well-supported versions of their tools\sepfootnote{stablecaveat}. Their older set of tools is more likely to have undiscovered (or unpatched) security vulnerabilities, but they are virtually certain to function properly and immediately allow the successful assembly of an \acrshort{eden} \gls{sa}. That set of probabilities seems very well suited to the expected audience for individuals first setting up their own copies of \acrshort{eden}: individual developers setting the system up to better understand it. When another team decides to deploy their own copy of \acrshort{eden} in a way that's available to the public, they can assemble that \gls{sa} using a balance of newness and stability that feels comfortable to them\sepfootnote{updaterisk}. 

   \subsection{Investigating Assembly}
   It's one thing to identify where the \acrshort{eden} install scripts sit in a cultural gradient. It's another to engage the particular choices that the \acrshort{eden} project has made. I chose to install a far newer set of tools, based on the projects newest recommendations for new installs \citep{Konig2019-ya}. I was guided by the \gls{python} 2.7 installation script provided on the Sahana \acrshort{eden} wiki\sepfootnote{edensetup}. However, I chose to use a version of \gls{python} originally released in 2016 (six years after the default version used by \acrshort{eden}). Using a newer version of python seemed like a sensible software engineering choice and also a way to check if \acrshort{eden} was, as they claim, able to operate equally well on the version I selected (3.6.9) and the 2.7 version that \acrshort{eden} uses by default\sepfootnote{pythonversion}.

   Selecting a more modern \gls{python} turned out to have knock-on effects. Some of the libraries that \acrshort{eden} requires are written only for \gls{python} 2.7 and replacements were needed to function with 3.6. One of the major changes was that the version of \gls{w2p} the \acrshort{eden} scripts installs does not support \gls{python} 3.6 and so I needed to chose an updated version. I selected 2.18.5, but this new combination of the \acrshort{eden} source code and the \gls{w2p} source code revealed that the two projects had drifted apart in small but essential ways. Specifically, in a section of the \gls{w2p} and \acrshort{eden} code that handled data validation.

   Data validation is, in general, the work of verifying that information conforms to a set of standards and informing the user how it has failed to conform when a problem is found. This should always be performed any time data is stored in a system. Digital storage systems have expectations that, when violated, can cause immediate systems failures. Web frameworks commonly provide facilities for verifying data and \gls{w2p} is no exception. \Gls{w2p} has components that will check that that user input can be converted to numbers or dates or email addresses, among others. \Gls{w2p} is open source and so all of that functionality can be expanded by programs that make use of \gls{w2p} and \acrshort{eden} does so in a number of places.

   \subsection{Shifting Relationships}
   In between the version of \gls{w2p} that \acrshort{eden} uses by default and the version of \gls{w2p} that I selected, the control flow of data validation has changed slightly. This change meant that custom data validation classes that were written using the older \gls{w2p} system no longer fit into the expected control flow of data validation. The \acrshort{eden} data validation code, based on the older standard, is not called properly when using the newer version of \gls{w2p}. This doesn't stop the successful assembly of an \acrshort{eden} \gls{sa}, but once that \gls{sa} is assembled most of its functionality in inaccessible because the \acrshort{eden}-specific data validation code won't run and so the system won't accept that data. 

   This problem is interesting because it turns out it captures a moment in time between the \gls{w2p} team and the teams that use \gls{w2p} (i.e. \acrshort{eden}). If I had selected a slightly earlier version of \gls{w2p}, then it would have used the old system and the \acrshort{eden} code would remain functional. \gls{w2p} immediately realized the problem and integrated a fix\sepfootnote{problemfix} for the issue. This shows the management of relationships that \citet{Mackenzie2006-hb} describes. There is the work of making software and then the subsequent and parallel work of adjusting that software to stay within relationships boundaries. The \gls{w2p} successfully implemented a new way of handling data validation control flow, but they neglected that they were doing it in such a way as to break an existing relationship they did not mean to break. Because I happened to select a version of \gls{w2p} that was temporarily out of relation with \acrshort{eden}, I failed to assemble a fully functional \gls{sa}. This was what got me interested in the assembly process itself.

   \subsection{Investigating Assembly}
   Assembly is a label I'm using to cover a variety of software processes that source code (and many other things) and produce \glspl{sa}. Almost all software is written in programming languages that have the dual goal of being possible for humans to understand and being suitable for mechanical translation into machine code. Machine code is, after all, the only language a computer can really understand \citep{Cramer2008-cw}. 

   Methods of assembly vary widely, but they can roughly said to lie between compilation and interpretation. The purest compiled language will generate a \gls{sa} that contains all the machine code that will be used by the \gls{sa} into a single contiguous piece of machine code. That machine code will generally only work on a single hardware architecture, but the same source code can be assembled\sepfootnote{compilelanguage} into machine code on other architectures by different assembly tool-chains. On the other side of this spectrum are interpreted languages. A purely interpreted language assembly process does not involve the generation of any new machine code. Instead, it uses a standard \gls{sa} (called an "interpreter") that reads the source code of the interpreted program in its human readable form like a recipe: reading the file(s) as the interpreted program executes and using machine code that exists within the artifact of the interpreter to tell the hardware what to do.

   There are also a variety of methods for \glspl{sa} to share access to centers of functionality. The most common is sending calls "out" to libraries. The pure compilation situation described above really only exists on hardware without a multitasking operating system. For every \gls{sa} on your phone or computer, the \gls{sa} will frequently make a call to a library (which itself sits somewhere between compiled and interpreted) where it specifies which library, which section of the library, and the information it would like to pass off. Then the operating system pauses the execution of the machine code in the \gls{sa} and loads the library (or the library's interpreter) to perform the requested task. When the task is done, the first \gls{sa} is loaded again and told the result. 

   Most languages and \glspl{sa} sit somewhere between being fully compiled and fully interpreted. \Gls{python} is largely an interpreted language, but it also creates non-human readable bytecode versions of each python source file that allow the interpreter to execute more quickly \citep{The_Python_Software_Foundation2020-qz}. \Gls{python} also allows access to libraries written in machine code and \acrshort{eden} invokes machine code libraries through \gls{python} interfaces.

   \subsection{Digital Relationships}
   These libraries exist on the border of all of the \glspl{sa} that use them\sepfootnote{staticlink}. They contribute to how the \glspl{sa} that use them behave. Flaws in libraries can allow the programs that use them to be taken over. Sometimes these flaws only require attention to discover, but it's often the case that other elements of the hardware / software ecosystem must change before they can be found \citep{Huang2003-ki}. All this is to say that the kind of assembly problem I encountered in assembling \acrshort{eden} is not particular to \acrshort{eden}. It's a universal concern when assembling \glspl{sa} that use any functionality that resides outside their own source code (which nearly all do).

   This system of linking together different code written by different people is an example of the relationships that \citet{Mackenzie2006-hb} found at the center of the software projects he studied. At the project level this means that a the people working on one project must pay attention to the development of many other projects. Are new versions of the libraries that you use being released? Will the old version be updated if security flaws are found? Does the new version have features or changes that would be useful for our project? 

   What is striking about the problems encountered while trying to assemble my own artifact of \acrshort{eden} is that, while every individual who assembles an \acrshort{eden} \gls{sa} will need to go through their own process, the problems I encountered are particular to using an un-patched version of \gls{w2p} 2.18.5. The install script I used contains other fixes for other aspects of that particular pairing of components, as well as different fixes for different combinations of components \citep{Sahana_Foundation2018-eq}. \acrshort{eden} can be assembled using an extremely wide set of components. It can run on that haven't been considered up to date for over ten years ago and components that are still considered cutting edge now (as well as many mixes between these two extremes). The \acrshort{eden} \gls{sa} is designed with this capability in mind. It is a strength of the \acrshort{foss} ecosystem that such a wide range of compositions is possible, but it also means that \acrshort{eden} can be a nearly limitless number of different \glspl{sa} whose qualities emerge both from \acrshort{eden}'s source code and the interactions between the particular versions of the components.

   \subsection{The Social and Material Components of Software}
   Keeping in mind the range of possible component sets for \acrshort{eden}, think back to the particular set used in the install script. I speculated the set in that script were selected because they're well known familiar to the \acrshort{eden} development team. They minimize the chance that people will mistake a problem caused by assembly for a problem that exists within the \acrshort{eden} source code.  

   When a particular \gls{sa} fails to function as expected, there are many possibilities as to why. It might be mis-configured, the resources it needs to function properly might not be available, there may be an internal incompatibility between components, or there may be an error in the \acrshort{eden} source code. There are many functional \acrshort{eden} \glspl{sa} that contain component combinations that the developers have never tried and have no experience with. When what appears to be an error is reported to the \acrshort{eden} team, often the first questions they ask are about the versions of the libraries that were involved. If the versions of the libraries being used aren't considered to be the correct ones, the bug can be closed as wholly or partially invalid \citep{Trendspotter2020-ps}.

   This method of engagement around questions of proper assembly and proper component selection are, above all, practical. Over time the number of possible combinations of all the versions of all the libraries will inevitably expand beyond the abilities of any team. To control this somewhat, teams will have defined periods of support and lists of appropriate versions of components and only fix problems that found within that somewhat limited domain \citep{Canonical2020-ru,Konig2019-ya}. But \glspl{sa} that are assembled using components drawn from outside the official set of components may still function. Being 'out of support' does not mean that things will not work. It means that the team managing the software project has no opinion about the relationships between their code and the components you're using. They will support the official supported combinations and leave you to do your best with the unofficial ones.

   This suggests a limit on the boundaries of the \acrshort{eden} software project. Maybe the unofficial \glspl{sa} that the \acrshort{eden} team won't support now aren't really \acrshort{eden} \glspl{sa}. However, I don't think it's that simple. What components (and versions of the \acrshort{eden} source code itself) are inside the 'official' \acrshort{eden} change over time. What is an unofficial \acrshort{eden} \gls{sa} might one day become an official software version as the \acrshort{eden} software project changes its thinking about relationships. By the same stroke, official versions will often become unofficial. The team recently announced that, with the end of official support for \gls{python} 2, they will be moving to using \gls{python} 3 for all of their builds and updating their install scripts to use \gls{python} 3. Suddenly, my \acrshort{eden} \gls{sa}, which already uses \gls{python} 3 is within the official definition and the \acrshort{eden} \gls{sa} assembled by the script on the Sahana website is unofficial \citep{Konig2019-ya,Sahana_Foundation2015-zs}. 

   \subsection{Software Exists Outside of the Social}
   Instead, I think what this shows is a material reality interacting with a social relationship. Each given version of \acrshort{eden}'s source code has a particular material relationship with each version of each component it could use. These relationships have an existence outside of any social system because computer code can be executed mechanistically \citep{Cox2013-zo}. The official / unofficial layer, where the team that writes the source code for \acrshort{eden} and sets forth the list of officially supported component relationships, exists on top of this material reality. But this social layer does not change what software \textit{is}.

   Understandings of software where only the official versions of \acrshort{eden} are "the software called \acrshort{eden}" lead to an understanding of software that defies common experience. It would mean that, once the \acrshort{eden} team announced that they were migrating away from \gls{python} 2, all of the \gls{python} 2 \acrshort{eden} \glspl{sa} that exist and function now suddenly stopped being software. It would also mean that, because I have changed some elements within the \acrshort{eden} source code\sepfootnote{sourcemodifications}, my \gls{sa} can no longer be \acrshort{eden} - even if I used all the official supporting components. It would require an impossible level of information about every component and every element of every \gls{sa} that appears to be \acrshort{eden}.

   Once we accept both official and unofficial \glspl{sa} are that software, it becomes clear that another social understanding exists along side just the official and unofficial version of software. Most people who encounter a particular software project have no idea if they are interacting with an official or unofficial version\sepfootnote{unofficialbinaries} (or that such a distinction even exists). So there exists this general social understanding about each piece of software (including \acrshort{eden}) that individual draw from their own experiences. These experiences might be with official software, unofficial software, or even be based on a mis-identification of the software (such as receiving a counterfeit product and leaving a bad review for the original) \citep{Suthivarakom2020-cp}.

   It's useful to draw out these different social experiences of software because it allows us to think in a more informed way about the impact of materialized perspectives. It is not just the source code of a particular software project that adds to its behavior, it is also the various components that source code is combined with. For those who only interact with post-assembly \glspl{sa}, the relationship of the software they are using to the official software is unknowable. Software that has the reputation for being unstable and unreliable can get that reputation because people are, knowingly or unknowingly, using pirated copies that crash because of anti-piracy code \citep{Fitch2008-vq}. The team that makes that piece of software may never know why people think its unstable, because they would need to understand the assembly processes that particular \glspl{sa} went through. The users may want the software to be different, but though the software team is the single entity most responsible for how a particular \gls{sa} functions, they may simultaneously be unable to understand or repair the problem.


   \subsection{Reckoning with Failures}
   After assembling a functional \gls{sa} I began to explore how my \acrshort{eden} \gls{sa} functions on its own terms. I did this by entering the high level details of this project into \acrshort{eden}'s project tracking feature. This included creating an entry for Drexel University's Center for Science, Technology and Society, an entry for my project within that organization, and an entry for myself as the manager of that project. During this process I encountered both a bug in the source code of \acrshort{eden} and another unacknowledged materialized perspective. 

   The form that \acrshort{eden} uses to record the details of an individual has a field for a phone number. There's no indication that this number number should be formatted in one particular way over another. I didn't think anything the lack of instruction until my \acrshort{eden} \gls{sa} informed me that I needed to "Enter a valid phone number" \citep{Konig2020-yx}. I didn't understand because my phone number was following the common conventions for phone number formats (I tried the 'xxx.xxx.xxxx' as well as 'xxx-xxx-xxxx' and 'xxxxxxxxxx'). Upon review of the source code of the file responsible for the message I discovered two things: that, based on a setting I was not aware of, the form was expected a phone number in international format (beginning with a '+' and a country code) and that the code was returning the wrong message (complaining that the input was not a phone number instead of complaining it was not an international phone number). After entering my number in the international format, my profile was created.

   % maybe conclusions
   This felt like an excellent situation to investigate. It appears, on first brush, that there are two layers of unacknowledged materialized perspectives: the first being requiring numbers to be in the international format without informing the user filling out the form, the second appears to be an error in the message returned. My background as a programmer and my access to the source code makes me want to say that the \acrshort{eden} project intends to require international numbers and failed to return the correct message about that requirement. However, I think it is worth considering how these two problems appear without access to the source code.

   First - imagine if the second problem was fixed (the \gls{sa} returned the proper error). When the user enters a number without a country code, the \acrshort{eden} \gls{sa} will reject their number and tell them it must be international. They now know what to do, but had no way to learn about the requirement before they failed to meet it.

   Second - imagine if the \gls{sa} informed the user they needed to enter their number with an international country code. But, when the code was left off, told the user their number wasn't valid. Again, the user would not be sure what to do to advance. It might be easier to find out (because the \gls{sa} has labeled the field with the requirement), but \textit{from the users' point of view} these two situations are very similar. It is only the ability to look into the source code that clearly sets them apart.

   % findings
   So, after discovering it, I decided to see what I could learn by giving back to the \acrshort{eden} project and fixing this (extremely minor) bug. I wrote and submitted a small patch that intended to fix the problem and check that the proper error message was returned. Unfortunately, much to my embarrassment, my fix was written incorrectly - it incorrectly eliminated another error message that could, in certain circumstances, be displayed to the user. As a result my fix was rejected, though once the \acrshort{eden} project was aware of the bug they immediately wrote their own fix \citep{Konig2020-ey}.

   In the discussion about why my fix was flawed, one of the \acrshort{eden} project developers said several interesting things about how he (and by extension the \acrshort{eden} project) think about software.

   \begin{quote}
   "And no, there's no test case as to what error message exactly is returned.

   Whilst we could unit-test it routinely, \textbf{regression-testing too much detail can add excessive rigor thus make development harder}. \textbf{A wrong error message is an annoyance, but neither does it break the intended functionality}, nor does it jeopardize the data integrity - so it is low priority and should probably not be CI-tested." \citep{Konig2020-yx}\sepfootnote{longquote}
   \end{quote}

   There are a couple of interesting ideas in this quote that, I think, can help us understand how software (or at least the \acrshort{eden} project) functions. First, there's the idea that testing too much makes development harder. Since K{\"o}nig is talking about regression testing (testing of fixed bugs) the difficulty would likely come from tests unexpectedly failing after changing related code or would come from work needed to update the test when changing the functionality it is testing\sepfootnote{ethnographylimits}. In any case, the decision to limit testing is also a decision to limit their automated testing to a certain subset of all program functionality. That development would be harder if the full scope of possible functionality was tested and that it is better to be ignorant about ancillary behavior like error messages.

   The second idea is that accepting or rejecting the number based on its use of an international country code (which it does successfully) and informing the user of what they need to do should be considered separately. That however the program appears to to the user, if it accepts numbers in the desired format and rejects others then the component is working. The statement reflects a world view that, if a component is expected to have multiple outputs for a given input, each output should be considered working or non-working separately and that there is a hierarchy to which functions are more or less important. 

   % discussion
   \subsection{Implications of my failed bug fix}
   Before going into the interesting aspects of the K{\"o}nig quote, I want to talk about something I find interesting about the context of how the discussion about the bug took place. This was, as I said, a discussion between people who both had access to one (or more) \acrshort{eden} \glspl{sa}. I originally noticed the bug when I was interacting with my \gls{sa}. This is in line with how most software projects come to have an impact on the world: through directly or indirectly affecting the world through the \glspl{sa} that the project produces or makes possible \citep{Kitchin2011-af}. While software impacts our lives in direct and indirect ways, those impacts derive from how one or many \gls{sa}(s) interact with particular human agents. Though software has made is possible to remove humans at many of the intersections of power, it is still expressed through a multitude of relational contacts between a representative of power (a person or a \gls{sa}) and a human outside that power \citet{Cheney-Lippold2018-lw,Deluze1995-eo}. 

   \subsection{Do Software Artifacts Matter}
   Given all of that, I think it's interesting to note that the entire discussion about bugs took place without referencing the behavior of any particular \gls{sa}. I've already speculated that the \acrshort{eden} project may recommend older components to minimize the risks of improper assembly and that questions \textit{about} the correctness of assembly are common \citep{Trendspotter2020-ps}. Because investigating the particulars of a misbehaving \gls{sa} are common, the lack of discussion here is interesting. 

   When a \gls{sa} is under discussion, that discussion often proceeds with the implicit goal of finding a mistake or a mismatched relationship in the assembly process. My bug fix, in contrast, was to a particular pre-assembly component. In order to realize my change, a new \gls{sa} would need to be assembled. Nothing in my attempt to fix the bug or in the eventual official bug fix can repair existing \glspl{sa} \citep{Konig2020-yx,Konig2020-ey}. This explains the lack of interest in any existing \gls{sa} - nothing about any \gls{sa} that might or might not express this bug is of interest. Instead, when the bug is fixed in a component of \acrshort{eden}, any potentially problematic \gls{sa} will be replaced with a new one assembled from updated components.

   % https://stackoverflow.com/questions/1945075/how-do-i-create-binary-patches
   To underline this point again - \glspl{sa} are never updated. When a 'patch' is applied to a \gls{sa}, the goal of that patch is to make the existing \gls{sa} identical to the \gls{sa} that would be generated by a fresh assembly. This means that a patch program is a new \gls{sa} that will effectuate a different assembly process than usual with the goal of producing the same outcome as a full re-assembly with all components \citep{Endsley_undated-iy}. It's also common for a \gls{sa} to contain many internal \glspl{sa} and for a patch to replace one or more component \glspl{sa} in full. However, the \glspl{sa} that accomplish these tasks of updating existing \glspl{sa} are separate \glspl{sa} in their own right. A software project can choose to utilize them or not utilize them, but their choice won't change how they "fix" problems found in an existing \gls{sa}. 

   The bug was fixed by changing a component with the intent of that component being assembled into a new \gls{sa}. It could also have been repaired by creating a new \gls{sa} to intentionally make changes to existing \acrshort{eden} \glspl{sa}, but this would need to be repeated for every previous \gls{sa}\sepfootnote{interpreted}. So \glspl{sa} are always replaced, because digital technology makes it easy to do so and the practical consequences are the same either way: a particular number of bytes in a particular order on digital storage. 

   This means that scholars must be careful when applying concepts whose identities were formed based on our collective experiences with physical goods. It's true that software is maintained, updated, repaired, cleaned, polished, and so on. Those operations often serve the same purpose as similar operations on physical tools, but the material character of how they are carried out will be dramatically different. This will impact the worlds of the people doing the work, the particulars of how these operations change the operation of software, and the proper weighting of concerns in assessing the impact of these operations. Because the material that composes the physical character of \glspl{sa} is cheap and plentiful (electrical charge), many of the previous systems that evolved in response to more complicated systems of material construction have limited implications for software projects and \glspl{sa}.

   \subsection{The Limits of Developer Attention}
   I want to briefly expand on the idea, expressed by K{\"o}nig, that testing in too much detail can harm software development. I think this idea, in combination with some discussion of assembly in the following section, will be helpful for thinking about agency in software. An uncharitable understanding of the idea that too much testing harms development is that developers might not care about some dysfunction, but I see no evidence of this. The \acrshort{eden} project immediately implemented a fix for the problem I found, even though they do not wish to add a test for it. 

   Instead, I think this approach reflects a \citet{Citton2017-xq}-esq approach to the problem posed by the enormous complexity of \glspl{sa}. In just the four libraries I focused on for this project there are over five hundred and fifty thousand lines of code\ref{tab:table-2}. The version of \acrshort{eden} I have been working on has seventy two authors (exuding myself). Even if each developer was contributing equally (which they are not), this would require each developer to test every single outcome of around seven thousand lines of code. This would be more code than many contributors have added to the project themselves. Without drawing conclusions about the degree to which developers have a responsibility to monitor behavior of their software artifacts, it seems very likely that it would be impossible for them to monitor all possible behaviors.

   The implication of this is not to let developers off the hook because monitoring all behavior is impossible. Instead I want to bring software development back to the social context that drives it. It seems like the \acrshort{eden} project is focused on how their components interact with data rather than how they interact with people. That is to say, they would rather create a \gls{sa} that gives the user incorrect information about its actions, but records the information that the developer expects. This runs the risk of becoming disconnected from user experience of \acrshort{eden}\footnotemark.

   \footnotetext{I have no reason to believe this has occurred.}

   This reflects a focus on \gls{sa} behavior that is inaccessible to users. It's true, to a certain degree, that users can be confused by particular elements of how a \gls{sa} is functioning and still have an overall impression of what 'it is doing.' However, the general impression of what \acrshort{eden} (or any \gls{sp}) 'does' isn't transmitted directly from the understanding of the \gls{sp}. Instead, those impressions are formed from users' many experiences with particular \gls{sa} in particular situations \citep{Boellstorff2015-al,Eubanks2018-hc,Schull2012-nc}. Often, users do not even have to interact with a particular \gls{sa} to form an impression of its impact \citep{Kitchin2011-af}. The experiential nature of how impressions of software are formed means that users are unlikely to change their impressions of the software because one or more message is wrong, but it seems certain that at some point users will feel misinformed to such a degree that their impression changes.

   The other risk is that the material qualities of the software and the messages it sends to its users begin to diverse in unsustainable ways. Developers can choose to have their \glspl{sa} send messages to users that don't reflect the internal state of the software, but this will likely make continuing to operate the hidden aspects of that \gls{sa} (and project) difficult \citep{Bivens2017-tc}. Producing a \gls{sa} that has external representations that aren't supported by all of its internal state means severing internal relationships and creating parallel internal functionality. 

   % survaliance
   All forms of testing are forms of surveillance. This makes testing practices vulnerable to the shortcomings of surveillance\footnotemark. It also reflects that \glspl{sp} recognize that their \glspl{sa} may not behave as they would wish. Surveillance systems are systems of control that are applied in situations where control is not certain. This suggests again that the expression of the agency of a \gls{sp} through their \glspl{sa} is not straightforward. The practice of surveilling \glspl{sa} through testing speaks to the potential for intent to be subverted through assembly. 

   \footnotetext{An expanded survey of literature on surveillance would be extremely useful here.}

   \subsection{What does Working Mean Here?}
   I want to return to talking about the various experiences of functionality and non-functionality I've encountered in this work \sepfootnote{working}. First I'm going to try and explore the ideas of assembly and then how to think about the functionality of assembled artifacts.

   Assembly is a process whose limits are challenging to clearly mark. There are instances where assembly is clearly successful, such as when a \gls{sa} works correctly in all ways or in instances where the failure of an assembled \gls{sa} clearly comes directly from a single flaw in a single component (such as the international number bug). There are also limits where assembly is clearly unsuccessful: when a component cannot be found, when a language that must be translated into machine code (or any language) is found to contain a syntax error \citep{Cramer2008-cw}. However, when I created a software artifact that failed to work because of a broken relationship between its components, I began to wonder if my definition of assembly was flawed.

   Unlike compiled languages, which fully parse their constituent source files before reaching a state where an executable \gls{sa} exists, Python \gls{sa} performs assembly immediately before executing a python program\sepfootnote{runtimeimports}. In fact, the \gls{python} assembly is piecemeal - each file is only read when needed, so files that are part of the \gls{sa} could go unused for any period of time before being used in the \gls{sa}. It would be possible to, for instance, begin running an \acrshort{eden} \gls{sa} and replace the line of web2py code that, if it were executed, would cause a crash. If the code was replaced before the \acrshort{eden} \gls{sa} called the code with the bug, no crash would occur. So do I need one approach for assembly with interpreted languages and another approach with compiled languages?

   No, because the apparent differences are illusions. Compiled programs can also have their contents changed mid-executions (this is the usual method for 'breaking into' a computer). Changing the contents of a program that has already been translated to machine code is simply much less convenient than changing the text in the source file of an interpreted language. The moment of failure that I encountered when web2py tried to invoke \acrshort{eden} code it no longer knew how to find was a moment where the computer tried to follow a chain of relationships. It would not be possible to know if any given instance of an \acrshort{eden} validator that inherits from web2py code would work correctly without running the program. This means that finding the error would require solving the halting problem, which is impossible \citep{Kaplan_undated-xy}. 

   For the purposes of this this project, what I call assembly is every aspect of preparing a program to execute that can be done without needing to actually execute the program (i.e. the limits of the halting problem). These processes (compilation, the locating of python files) are often themselves executed by \glspl{sa}. As long as the work being done could be done without executing source code, it is considered part of the assembly step\sepfootnote{pythonexeq}. 

   Why is this important? Does it matter for sociologists when assembly stops and execution begins? The end of assembly is the point where human intervention into a \gls{sa} largely stops being useful. After assembly is complete, the balance of which components will impact the overall behavior of the \gls{sa} is fixed. The only human intervention that is possible is the decision to start or stop the \gls{sa}\sepfootnote{askingforhumaninput}. This is doubly important because our ability to predict what a \gls{sa} will do when it is executed is hampered by both practical and theoretical limits \citep{Kaplan_undated-xy}. 

   This reality is reflected the practice of testing in the development of \glspl{sa}. The \acrshort{eden} \gls{sa} assembled in \acrshort{eden}'s test code is not exactly like the final \gls{sa} (it largely differs in the database entries that compose it), but the goal is to make it as close as possible to the final \gls{sa}. For instance, the assembly error I encountered with web2py was easily detected by tests. Testing is a reaction to the fixing of agency in a \gls{sa} and an attempt to ensure that the agency reflected in the final \gls{sa} is sufficiently similar to the developers' intent. These tests can take the form of source code that is incorporated into one or more testings \glspl{sa} or in planned interaction with the final \gls{sa} before releasing it to the public. 

% =============================================================================
% =  __  __         ___       _                            _   _              =
% = |  \/  |_   _  |_ _|_ __ | |_ ___ _ ____   _____ _ __ | |_(_) ___  _ __   =
% = | |\/| | | | |  | || '_ \| __/ _ \ '__\ \ / / _ \ '_ \| __| |/ _ \| '_ \  =
% = | |  | | |_| |  | || | | | ||  __/ |   \ V /  __/ | | | |_| | (_) | | | | =
% = |_|  |_|\__, | |___|_| |_|\__\___|_|    \_/ \___|_| |_|\__|_|\___/|_| |_| =
% =         |___/                                                             =
% =============================================================================

  \section{Taking Action}
  A primary motivation for this project was the sense that situated knowledges felt like an unfinished tool for the practice it was critiquing. Our ability to see the truth is impacted by our life circumstances. Individuals cannot identify false truths that only appear true because that individual exists within a structure of power \citep{Haraway1988-nh}. Situated knowledges explains the mechanism through which we inappropriately consider things true or objective, but it is of little use in understanding to affect changes to the things impacted by our limitations. 

  If \glspl{sp} incorrectly believe things because of the collective backgrounds of their members, convincing them of that truth does not help them address it. The same cultural limitations that hem in action would also seem like they would hem in the process of selecting outsiders to help address the problem.

  So I hoped to find ways to understand better how to address the standpoints of development teams through any materialized perspectives I might find within a \gls{sa}. I took a wide view of what "address" might mean - it could be a direct improvement, it could be a way of highlighting alternatives, it could be tools that help teams see the boundaries of their own perspective. As I worked, however, it became clear that without an ethnographic engagement this goal faced real difficulties.

  \subsection{Improved for Who}
  No sociological work is needed to learn how to improve the \acrshort{eden} \gls{sa} from the point of work of the project. If I want to improve \acrshort{eden}, doing so is simple. The \acrshort{eden} project Github has a number of minor issues with details about what change is needed to improve the \gls{sa}. They also communicate about their long term plans and are open and encouraging of outsiders and users alike joining in to comment on what they would like to see in future \acrshort{eden} \glspl{sa}. These conversations share the qualities that make accessing them difficult to users who aren't members of the right social groups (a focus on technical details, cultural signals of developers), but those are problems shared by the world of software and don't derive from specific qualities of the \acrshort{eden} project \citep{Drexler2019-tk,Kelty2008-jm}.

  My decision not to engage with populations that use \acrshort{eden} \gls{sa} means that I have no reason to believe I can understand the interests or needs of people who might use the software. Even taking \citet{Kitchin2011-af} into account and proceeding from the point of view that the software might impact space in particular ways outside of particular individuals is not much help. I am not experiencing a disaster\footnotemark and even if I was it's unlikely that I have a sense of how \acrshort{eden}, among all the factors, was impacting me. That kind of work benefits from longitudinal work that I was not planning or prepared to do.

  \footnotetext{Part way through this project I, and most everyone else in the world, experienced the Covid-19 pandemic. As of this writing, the pandemic is ongoing. However, I have no way of appreciating how \acrshort{eden} would impact me were it mediating my access to supplies or services. I could not replicate that power relationship and it would be inappropriate to act as if I had.}

  Thankfully, a perspective I can hope to make improvements from is the perspective that I hold: that of a software engineer and a science, technology \& society scholar. I was aware that assembly processes were involved in the creation of \glspl{sa}, but it was only as I worked on this project that I began to focus on them. These processes are involved, but not particularly meaningful, when software includes only the work of one author (or, more often, one author and the \gls{sp} that produced the compiler / interpreter). However, as \glspl{sa} grow to include artifacts (software or otherwise)from many different \glspl{sp}, it seemed like there were real questions of agency involved. 

  If I make a \gls{sp} and its products are used to do harm, how can I understand my role in that? Certainly, that a tool I created is turned to harmful ends is worth considering. The idea that developers' responsibility stops once they've released their work to the public is absurd. There are an enormous number of efforts, both at the software and legal levels, to ensure that software is used in ways that its creators accept \citep{Gabriella_Coleman2012-lq,Kelty2008-jm}. There are few easy answers to be had, but as it stands there are few tools to help software developers assess how much their work has contributed to another. 

  \subsection{The Goal of My Intervention}
  I decided to make a tool that would connect Git repositories and \Gls{python} files using the \Gls{python} import system. The tool traces a path from file to file, using import statements to connect them. It will try to record if an entire files is imported (as in 'import X') or if smaller portions are imported instead (as in 'from X import a, b'). After locating the relevant files, the program collects all of modifications associated with them recorded in the Git repository. Then it matches the identities attached to each modification to each file. Finally the tool assembles a list authors and a list of lines of code in specific files that are contributing to the function of a particular file.

  My hope in building this tool and not another was to highlight the material contributions of the work of various authors to a particular source file. This doesn't reflect anything close to all of the work that has contributed this particular file existing over all other possible files (there are many other factors: the cultural context of each particular files' creation, the immediate and long term goals of the functionality the file attempts to implement, etc). However, for every element of a \gls{sa}, there is a concrete set of components that affect that elements' function and those components have a concrete set of authors. I hope this will be a useful starting point.

  I named my the \Gls{python} module containing my tool \textbf{materiality}.

  \subsection{Finding the Pieces}
  First, I should briefly explain the relationship \Gls{python} modules and \Gls{python} source files. The idea of a \Gls{python} module is used to organize functionality within the \Gls{python} programming language. A \Gls{python} module contains \Gls{python} objects (including, possibly, other \Gls{python} modules). Each \Gls{python} module contains at least one \Gls{python} source code file. A \Gls{python} module that does not contain other \Gls{python} modules contains exactly one \Gls{python} source file. A great deal of the work \textbf{materiality} does is connecting logical modules mentioned in \Gls{python} source files to particular files in particular places in storage. As a result, I will frequently be talking about 'modules' or 'files' nearly interchangeably: the module being the logical representation inside the \Gls{python} \gls{sa}, the file being its material instructions stored on the computer.

  I started by trying to use existing \gls{python} libraries to scan \Gls{python} code, but found that they weren't well suited to the task. The first library I looked in to, py2deps, was based on a command line tool for making graphical representations of the libraries used by a \Gls{python} \gls{sa}. This seemed very similar to my purpose, but it turned out that py2deps did not differentiate between using some or all of a python library. Its interest was detecting if a library was involved in any way and did not differentiate between using some and all of a library. I tried some other libraries, but none of them seemed to match my desired feature set: finding import statements and connecting an import statement to one or more lines in the referenced file.

  After being unable to find a \Gls{python} library to do what I wanted, I decided to use the abstract syntax tree (AST) functionality in the \Gls{python} standard library. A \Gls{python} AST is generated by reading a file of \Gls{python} source code. The resulting AST will contain all the \Gls{python} statements in the file it read, but expressed as structured objects in \Gls{python}. This capability was originally written to allow the processing and execution of \Gls{python} source code by the \Gls{python} \gls{sa}, but it can also be used to help \Gls{python} programs process \Gls{python} source code for other purposes.

  I used the AST module to parse each \Gls{python} file I wanted to investigate and catalog three things within each file: the import statements, anything that ads a symbol to the symbol table (as they may be imported), and the line number of each statement in the file. Once I had code that could extract this information from any properly formatted \Gls{python} file, I was ready to begin the real work of collating contributions from various authors.

  \subsection{The Algorithm}
  \singlespace % it looks bad if I don't single space the brief intro sentances
  Briefly, here is the high-level algorithm \textbf{materiality} implements. The first \Gls{python} file is provided to the tool and will be referred to with the name \textlangle first\_file\textrangle.
  \begin{enumerate}
    \item Create an empty index of python files named \textlangle imported\_files\textrangle.
    \item Create a list \textlangle files\_to\_scan\textrangle with \textlangle first\_file\textrangle in it. 
    \item While there are any file locations in \textlangle files\_to\_scan\textrangle, do:
    \begin{enumerate}
      \item Remove a file location from \textlangle files\_to\_scan\textrangle.
      \item Build an AST (referred to as \textlangle AST\textrangle) from that \Gls{python} file
      \item Add this file location to \textlangle read\_files\textrangle (a list of files I have already read).
      \begin{enumerate}
        \item Create a new tracking \textit{object} named \textlangle file\_info\textrangle
        \item In \textlangle file\_info\textrangle, record:
        \begin{itemize}
          \item Any \textit{import statements} found in \textlangle AST\textrangle
          \item The \textit{symbols}\sepfootnote{symbol} generated by any \textlangle AST\textrangle nodes, as well as what those symbols would contain.
          \item The lines associated with each \textit{symbol} found in the \textlangle AST\textrangle.
        \end{itemize}
        \item For each \textit{import} in \textlangle file\_info\textrangle try to find a particular file that it refers to:
        \begin{enumerate}
          \item Try to locate a file using several techniques, not all of which apply to all \textit{imports}:
          \begin{itemize}
            \item If the \textit{import} is relative, navigate the file structure searching for the file it refers to.
            \item Ask the \Gls{python} \gls{sa} to locate the file for the \textit{import}.
            \item Ignore \textit{imports} that fit these descriptors:
            \begin{itemize}
              \item \textit{Imports} that come from the python standard library (I did not know how to account for elements of this code that exist in within the \Gls{python} \gls{sa}).
              \item \textit{Imports} which, when asking the \Gls{python} \gls{sa} to find them, returned an error.
            \end{itemize}
          \end{itemize}
          \item If there is a copy of the \Gls{python} file I located in a Git repository, use the file located within the Git repository.
        \end{enumerate}
        \item Add the file locations to \textlangle files\_to\_scan\textrangle as long as they meet these requirements:
        \begin{itemize}
          \item They were not ignored as described above.
          \item A particular location could be found.
          \item This location is not already stored in \textlangle read\_files\textrangle.
        \end{itemize}
        \item If the file location was added to \textlangle files\_to\_scan\textrangle do the following:
        \begin{itemize}
          \item Retrieve the list of changes and associated authors made to this file from the appropriate Git repository and add them to \textlangle file\_info\textrangle.
          \item Add \textlangle file\_info\textrangle to \textlangle imported\_files\textrangle.
        \end{itemize}
      \end{enumerate}      
    \end{enumerate}
    \item Empty \textlangle read\_files\textrangle. 
    \item Create am empty tally of authors and change numbers named \textlangle changes\textrangle.
    \item Load the \textlangle file\_info\textrangle associated with \textlangle first\_file\textrangle from \textlangle imported\_files\textrangle.
    \item Repeat the following for each \textlangle file\_info\textrangle selected:
    \begin{enumerate}
      \item Add this \textlangle file\_info\textrangle to the list of \textlangle read\_files\textrangle.
      \item Add the stats associated with this file to \textlangle changes\textrangle.
      \item Examine each \textit{import} in this \textlangle file\_info\textrangle:
      \begin{itemize}
        \item If the \textit{import} is not in \textlangle read\_files\textrangle yet, select it and repeat this process.
      \end{itemize}
    \end{enumerate}
    \item \textlangle changes\textrangle now contains the list of authors and files which have an impact of the contents of \textlangle first\_file\textrangle.
  \end{enumerate}
  \doublespace

  This produces a list of as many authors as possible and generally characterizes their particular contributions to \textlangle first\_file\textrangle. As of right now, there are a number of flaws in the results and I would not recommend anyone use \textbf{materiality} without it being further developed\footnotemark. 

  \footnotetext{Also, \textbf{materiality} is currently sitting in the \acrshort{eden} repository for no particular reason other than I was using \acrshort{eden} as an object of analysis. The module name is "materiality."}

  \subsection{Methodological Choices}
  There is not one obvious way to approach this and my tool reflects my choice to approach things one way over other ways. I want to briefly acknowledge and situate those choices.

  First is that this tool collects changes over time and not simply the authors who are responsible for the last changes to each particular line in a file. This is an attempt to reflect the way that files change over time and are touched by many hands. Git will record the last person to change each line, but those changes are almost always based on a lineage of work that stretches back in the history of the file. On the other hand, this approach risks elevating substantial work from the distant past over recent and more impactful work. This concern is pervasive throughout the tool.

  Second is that the tool ignores \Gls{python} system libraries, though \Gls{python} libraries are used throughout the \acrshort{eden} code. \Gls{python} system libraries are libraries whose functionality comes both from \Gls{python} source code and functionality within the machine code of the \Gls{python} \gls{sa}. I avoided counting them because I was unsure about how to account for that mixed responsibility. Including system code would mean fully grappling with cross-language material connections in a way I'm not prepared to do.

  \subsection{Flaws in Current Functionality}
  \textbf{materiality} is a flawed creation. I was learning about the details of how \Gls{python} handles import statements, the \Gls{python} AST and a number of other elements of the \Gls{python} ecosystem. This project was also built in concert with the academic work to bring this software into conversation with STS literature over a relatively short period of time. The result is deeply flawed. I will briefly go over known problems.

  The interaction of \Gls{python}'s system for referring to modules and my management of the \Gls{python} symbol table has a number of problems. To explain I need to go into some detail about these two systems and how they interact.

  \subsubsection{A Brief Overview of Symbols}
  Symbol tables in \Gls{python} generally follow patterns in other languages. \Gls{python} maintains a list of all \Gls{python} libraries, with each \Gls{python} library taking on either the name of the file the library is defined in or, if there is more than one file, the directory the library is contained\sepfootnote{moduledetails} in. Each \Gls{python} file that the \Gls{python} \gls{sa} has seen is either recorded as a library, or (if that file is a component of a larger python library) as a sub-section of a \Gls{python} library. This means that, for instance, my library is named \textit{materiality} because that is the name of its directory. The \verb|ast_crawler.py| file is stored under the \textit{materiality.ast\_crawler} label.

  This system is used by \Gls{python} to avoid redundant loading and processing of \Gls{python} source code. The first time \textit{materiality.ast\_crawler} is encountered the \Gls{python} \gls{sa} loads and processes that file. On subsequent encounters \Gls{python} refers back to its previous work. 

  A similar system is used to track objects \textit{within} \Gls{python} modules. Various \Gls{python} statements (including import) add entries to a table of names and their associated \Gls{python} objects. The behavior of this system can become complex, but at a high level it functions like the \Gls{python} module system - symbol tables can be navigated using names separated by dots. For example, returning to \textit{materiality.ast\_crawler}, \textit{ast\_crawler} contains the \Gls{python} object \textit{ImportReference}, which in turn contains a value named \textit{SYSTEM\_LIBRARY}\footnotemark. To bring this value into your python module, you could write \verb|import materiality.ast_crawler.ImportReference.SYSTEM_LIBRARY|. This import statement causes the \Gls{python} \gls{sa} to navigate into a directory, select a particular file, then make two selections from two symbol tables. 

  \footnotetext{This constant is used to mark import statements which refer to \Gls{python} system libraries.}

  \subsubsection{Symbol Trouble}
  The current version of \textbf{materiality} frequently has trouble with symbol tables. If I understood exactly why, then I would have fixed the problems, but I can do my best to catalog them.

  Some \Gls{python} statements that add a symbol are simple to process: function definitions, object definitions. However, there are instances where symbol creating statements (such as assignment operations using the '=' sign) have complicated structures. For instance, one might write: \verb|(a, (b, (c, d))) = function_call()|. There's an implicit structure to this statement that I can write out\footnotemark, but I was unable to write \Gls{python} code that handled situations like this one. Doing so would require reference objects that stand in for the results of future \Gls{python} \gls{sa} operations. It's also worth noting this flaw would require moving beyond the assembly step, which I was not prepared to do.

  \footnotetext{In this case, if we refer to the value of function\_call() as X, the symbol table would look like this: $a\Leftarrow X[0]$, $b\Leftarrow X[1][1]$, $c\Leftarrow X[1][2][1]$, $d\Leftarrow X[1][2][2]$} 

  Another problem is that, simply, there are instances where my programming errors have made it difficulty to navigate the shared file \& symbol table structure I outlined above. There are many errors in the logs which indicate that my tool is unable to match an import statement against my version of the appropriate symbol table. I suspect many of these problems are caused by the fact that I don't (as \Gls{python} expects), add things that are imported to the symbol table of the module they are imported into. For instance, the long import statement I used as an example previously (\verb|import materiality.ast_crawler.ImportReference.SYSTEM_LIBRARY|) would add a \verb|SYSTEM_LIBRARY| symbol to the symbol table of the module. The current version of my tool does not do this and many \Gls{python} modules make use of this technique.

  I believe that these errors minimally impact the results. \textbf{materiality} does not take into account duplicate references to the same file and I believe that most problems with how I handle symbols would not result in adding any new authors or lines to the overall totals. 

  However, the flaws in my work on symbol management and others which I will go over in a moment, indicate that my methodological approach when writing this program is flawed and the results should be treated as highly suspect. I believe they are still interesting and informative even in their less-definitive state. 

  \subsubsection{Counting Errors}
  The initial "final" version of \textbf{materiality} was double (and more) counting files connected to the target of its analysis. I had written a system that was intended to, for a given symbol, return information only on \textit{the section of the module containing that symbol}. In fact, much of my development time was spent trying build a system that would achieve that granularity. Unfortunately, it does not seem like I succeeded (or I failed to properly collate the results). In any case, modules that were accessed through specific symbols inside the module (as opposed to importing the entire module / file) had the change counts for the entire module

  \subsubsection{Other flaws}
  There are other signs that I have made mistakes. Though the structure generated by this algorithm should be a true tree if it is constructed properly (import statements must form a tree), trying to navigate the entire structure results in infinite loops. I do not understand why. 

  Were I to do this again, I would build a clean internal representation that smooths the difference between the computers' file structure and a python objects' symbol table, but I did not understand I needed to do this early enough and the current code is a mess. 

  The procedures for associating a particular \Gls{python} file with a particular \Gls{python} likely could fail less often. However, without adding records of when and how they fail that are reported at the end of the process, estimating the impact of an improvement in this area is difficult. I also do not evaluate if import statements are used. Its entirely possible for a file to import a \Gls{python} module that it does not use (I have unused imports in the work I did for this project). These can be detected, but I do not do it.

  Finally, there were cases where overlapping errors collaborated to produce a functional \gls{sa}. In one place I designed the system for processing \textit{import} statements to mark an import as invalid if the \Gls{python} \gls{sa} could not locate a file for it. However, in another place, I ignored that marker and assigned it a file based on the module name the \textit{import} referred to. Each system ignoring the other was an unintentional omission, but in combination they produced a functional system (albeit one that frequently falsely complains it can't find a module).

  \subsection{Foreseeable Improvements}
  I will also briefly catalog things I think could be improved about this work. This will both sooth my frustrations and mark what directions the \textbf{materiality} \gls{sp}, as it exists today, could be taken in.

  \subsubsection{Deeper Engagement in Git}
  The current version of \textbf{materiality} engages with modification history recorded in git in a very shallow manner. It crudely counts changes to files without reference to content. It does not detect when a file has been moved. It can't tell the difference between a truly new file and a new file that is created by removing some of the content of an existing file. Any time source code is copied or moved its history is lost. Not all of these scenarios are clearly detectable - text matching can be difficult and uncertain - but an effort could be made.

  \subsubsection{Change Distance}
  The most obvious improvement by far would be for \textbf{materiality} to characterize the distance of the various impacts in some way. At the moment, if any file can be reached through the tree of imports leading out from the one \textbf{materiality} starts from, its authors and change counts are added to the list without adjusting for the distance. This means tallying work directly on the file of interest and work on, say, a file used by a related library to print error messages would be displayed in an undifferentiated way. The current \gls{sp} tosses all change counts and authors into a single category, which is obviously wrong.

  Bringing a sense of distance, or varying amounts of weight, would also be an opportunity to apply the sociological theories that form the theoretical background for my thinking in this project. Both linking together various \Gls{python} files and attempting to weigh the relative impact of those links recalls \citet{Mackenzie2006-hb}'s work on how relationality structures \glspl{sp}. It also reminds me of \citet{Haraway2016-nc}'s notion of "tentacularity" - the relentlessly interconnected nature of the world and how that wealth of connections to enliven our sense of the possible. It's also clear that the way \textbf{materiality} works now - making no effort to characterize how any particular change is related to the file being analyzed, is the kind of 'god trick' that \citet{Harding1992-od} and \citet{Haraway1988-nh} set out to critique. I have created another view from nowhere.

  I do not know now what the best way to characterize the disparate contributions from changes at different points in the tree of related files. Usage analysis could be a large improvement. Import statements add objects to to the module symbol table and \textbf{materiality} could analyze the usage of those objects. Carrying this practice across the entire import tree would highlight links of action (as opposed to an undifferentiated link). As noted previously, however, such an analysis might be deceptive. There are real limits to how much static analysis of computer programs can predict the behavior of those programs \citet{Kaplan_undated-xy}. As much as the current program is a view from nowhere, I want to be mindful of the possibility of rendering a false view.

  \subsubsection{Ways of Seeing}
  The current output of the tool is, to put it bluntly, opaque. Quoted below is a sample output from the \textit{adapters} module in the \textit{pydal} module. This is not the final output, but is as close as the \gls{sa} can come to displaying the web of connections. 

  \singlespace
  % https://www.overleaf.com/learn/latex/code_listing
  % https://tex.stackexchange.com/questions/171803/change-font-size-of-the-verbatim-environment
  \begin{Verbatim}[fontsize=\small]
    </Users/ddrexler/src/python/web2py/gluon/packages/dal/pydal/adapters/ __init__.py>
    SM[pydal.adapters]-> Module[]
      Imports:
        [1]Import <!S>re
        [2]From <+R>pydal._gae Import gae
        [3]From <+R>pydal.helpers._internals Import Dispatcher
        [71]From <+R>pydal.adapters.base Import SQLAdapter,NoSQLAdapter
        [72]From <+R>pydal.adapters.sqlite Import SQLite
        [73]From <+R>pydal.adapters.postgres Import Postgre,PostgrePsyco,PostgrePG8000
        [74]From <+R>pydal.adapters.mysql Import MySQL
        [75]From <+R>pydal.adapters.mssql Import MSSQL
        [76]From <+R>pydal.adapters.mongo Import Mongo
        [77]From <+R>pydal.adapters.db2 Import DB2
        [78]From <+R>pydal.adapters.firebird Import FireBird
        [79]From <+R>pydal.adapters.informix Import Informix
        [80]From <+R>pydal.adapters.ingres Import Ingres
        [81]From <+R>pydal.adapters.oracle Import Oracle
        [82]From <+R>pydal.adapters.sap Import SAPDB
        [83]From <+R>pydal.adapters.teradata Import Teradata
        [84]From <+R>pydal.adapters.couchdb Import CouchDB
  \end{Verbatim}
  \doublespace

  This form was designed to help me understand what the program was and was not finding. The numbers in \verb|[]| are line numbers in the \verb|__init__.py| file. The symbol and letter inside the \verb|<>| symbols indicates the status of the import. \verb|<!S>| signals that this import refers to a system library and will be ignores. Import statements with a \verb|<+R>| mark are relative imports whose referent has been successfully found\footnotemark. 

  \footnotetext{For example, the import on line 2 was originally written "from ..\_gae import gae", the program has checked that this file can be found and changed from a relative path to an absolute path within the \textit{pydal} module.}

  However, many different graphical displays would be possible. The file itself could be laid out and sections of text connected to the tree of python files that influence that texts' behavior. \textbf{materiality} could generate graphical representations of the networks of \Gls{python} modules involved. Instead of focusing on the files themselves, the collaborations between authors could be highlighted. Each file could seen as moving between contributors over time and \textbf{materiality} could render a graph of how the feature being analyzed had been built by humans in specific ways and at specific times in the past.

  \subsection{The Materiality of Validators}
  In some sense, the tool speaks for itself. It is, as is all \glspl{sa}, materialized intent. There is a level of understanding of \glspl{sp} and artifacts that can only be acquired through interacting with them. However, it's no fun to make something and not show it off.

  \subsubsection{Validators by the Numbers}
  Below are the results of running \textbf{materiality} on the \Gls{python} file\footnotemark containing the validators that I repeatedly encountered while engaging the \acrshort{eden}. This file is responsible for checking that data inputs are in line with expected formats. The validator with the bug I tried to fix ensures an input it is given matches the format of a phone number. Some other validators defined in the file check that an input is the proper format for latitude, is a number or is a UTC date \& time. Each validator builds off of and is connected to the the Validator object in the web2py project, which provides common operations used in accepting or rejecting user inputs.

  \footnotetext{The path inside \acrshort{eden}'s repository is /modules/s3/s3validators.py}

  \begin{table}[ht]
  \caption{Result Summary}
  \label{tab:result-summary}
  \begin{tabular}{|l|l|}
  \hline
  Authors Involved               & 119                                   \\ \hline
  Files Involved                 & 86                                    \\ \hline
  Lines of Code                  & 41,226                                \\ \hline
  Total Change Count to Files    & 170,806                               \\ \hline
  Longest File Active Lifetime   & 8 years                               \\ \hline
  Average File Active Lifetime   & Between 4 and 5 years                 \\ \hline
  \end{tabular}
\end{table}
  
  \begin{itemize}
    \item The author count includes myself, because I (defiantly) merged my fix to the bug I found in the phone number validator (after changing it to work correctly).
    \item The count of files show here involved includes the \verb|s3validators.py| file \textbf{materiality} was given. 
    \item File active lifetime should be understood as the period of active work on that file. For example, if a file was created 6 years ago and last changed 4 years ago it would have an active lifetime of 2 years.
    \item These data are summaries of a larger dataset. An author-by-author breakdown can be seen in a section at the end of this paper and even more detail is accessible through a Google sheet whose link can be found in the same section.
  \end{itemize}
  
  These results highlight the collaborative nature of software development, especially \acrshort{foss} software development. There are many authors and files that support the various Validator classes \acrshort{eden} has defined. In particular, it's interesting that these files contain just over forty thousand lines of code, but over four times that number of lines have been added or removed from those files. This shows how code changes and evolves over time and highlights how software is not any particular version of the source code or \gls{sa}, but a process and practice that occurs over time \citep{Mackenzie2006-hb}.  

  Diving a little deeper into the data, it's possible to characterize the weight of the impact from the different projects on the set of validators defined in \verb|s3validators.py|:

  \begin{table}[ht]
  \caption{Percent of Involved Changes By Project}
  \label{tab:change-locations}
  \begin{tabular}{|l|c|c|}
\hline
\textbf{Project} & \textbf{Location of Connected Changes} & \textbf{Connected Changes As \% of Project} \\ \hline
Eden                  & 16.1\%                                       & 0.44\%                           \\ \hline
web2py                & 62.2\%                                       & 3.30\%                           \\ \hline
pydal                 & 20.7\%                                       & 9.23\%                           \\ \hline
yatl                  & 1.1\%                                        & 77.75\%                          \\ \hline
\end{tabular}
\end{table}

  I think the most interesting thing here is how the work on the shared Validator class from web2py is reflected in this breakdown. The \acrshort{eden} team is able to do less work by relying on the work put into the object(s) they are extending (and the other objects inside web2py that support that foundational work). It would also clearly help if I had some method that accounts for project size - \acrshort{eden} is over four hundred and sixty times larger (\ref{tab:table-2}) than yatl, meaning that 0.44\% of \acrshort{eden} is likely\footnotemark more work than 77.75\% of yatl.

  \footnotetext{The reason I say likely is that I'm not sure how to compare the total number of changes in the entire repository (which include the non-\Gls{python} code) to the language-specific line counts in \ref{tab:table-2}.}

  \subsubsection{What can't be Seen}
  I'll reflect more on this in my discussion on possible improvements, but I should note here the overwhelming flatness of my results. There is a myopic quality to looking at programming in this way. The act of displaying all the contributors together, without differentiation, is itself a \citet{Haraway1988-nh}-esq god trick. It took a good amount of work to get to this point - more than I'd like to admit and more than a good programmer would need. I believe there is worth in these results as a reflection of the exercise and the exploration, but they are a snapshot from a journey that may never be completed - not a triumphant demonstration of the ideas I've been speaking about.

  \section{Returning at last to Software}
  I opened this paper and this project by asking how assembly mediates agency in software. The literature is clear, and I agree, that there is a strong connection between \gls{sp} intent and \gls{sa} behavior. The \acrshort{eden} project describes their mission as "sav[ing] lives by providing information management solutions that enable organizations and communities to better prepare for and respond to disasters" and nothing I found in the \acrshort{eden} source code or the \acrshort{eden} \gls{sa} suggests that the impact of \acrshort{eden} follows their ambition \citep{Sahana_Foundation_undated-hl}. The complexities of software development do not change the previously established connection between tool impact and creator intent \citet{Subramaniam2014-wg}. 

  I also found, at every turn, material qualities of software that threaten to escape the ability of creators to detect and tools to prevent. One consequence of this is that software developers are expected to trigger and manage the assembly processes for any \gls{sa} they wish to work on. The experience developers derive from that is key to learning about the components used by the \gls{sp} in the \gls{sa}, but it redoubles the limited view already embodied through \gls{sp} surveillance of \gls{sa} (\textbf{The Limits of Developer Attention}). Any developer who engages with the components (source code, \gls{sa} libraries) and the \glspl{sa} of a \gls{sp} is constantly experiencing suggestions about the nature of the world. Within König's idea that "testing too much detail can add excessive rigor," I see a world view that the correct way to imagine and survival software is attending to a particular set of behavior over all others \citep{Konig2020-yx}.

  The \acrshort{eden} project and the \acrshort{eden} \gls{sa} is not equipped to detect deviations in behavior they are not watching. Once a \gls{sa} is sent out into the world, its behavior is fixed. Problems discovered within it will need to be worked around or the problematic aspect ignored until it is replaced. \citet{Latour1999-ui}'s concept of blackboxes rested on the work of making complexity socially invisible, but that's not exactly what I see here. In both \textbf{What does Working Mean Here?} and \textbf{Software Exists Outside of the Social} I encountered an object whose behavior defied shared social understandings. It was not just that my \acrshort{eden} \gls{sa} 'broke,' but that it broke in a way that was particular and limited way. In the case of the phone number message, the failure fell outside the sight of the \gls{sp}. The other failure was cause by my choices in assembly. Both failures could only be understood by looking inside the assembly process but, critically, not inside the particular \glspl{sa}. Unlike a blackbox, whose contents become socially visible\footnotemark when they fail, \glspl{sa} keep their secrets. I think I need an updated idea. 

  \footnotetext{To elaborate on this theme, Latourian blackboxes do not actually prevent people from seeing what is inside them. He is instead trying to speak to why people \textit{can} operate \textit{as if} the internals of a blackbox are invisible. The fact that blackboxes contain other blackboxes goes to show that everything within a blackbox has a social identity that people can and will recognize and interact with if they are shown it. \glspl{sa} on the other hand, have their internals transformed from an object that some can understand (source code) to something nearly totally opaque to everyone (machine code).}

  \subsection{Composites}
  Software artifacts are not blackboxes, they are \textbf{\glspl{cmp}}. \Glspl{cmp} are fixed assemblies of more than one component which inherits the material qualities of its components, mediated through the structure which those components are assembled into. Once assembled, a composite can operate without human intervention. Composites are typified by extremely high internal complexity and complex behavior, but once assembled their possible actions are set. Composites cannot be changed, only replaced. Each component of a composite may be an instruction or a datum, but they are generally composites themselves. Generally, each component makes a proportional contribution to the material qualities of the composite it is integrated into, but layers of assembly can place components in unexpected relationships with unforeseen outcomes.

  The identity of a \gls{cmp} derives from its behavior, not its label. The different \glspl{sa} of \acrshort{eden} are not similar because they share the label "eden," they are similar because they are largely constructed from the same components. As \acrshort{eden} evolves and changes over time, its social identity will "stretch" to reflect a diversity of behavior, but that same stretching betrays that multiple objects with different qualities are sharing a single label. Eventually \glspl{cmp} that share many, but not all components will be given separate labels or face a collapse in the usefulness of the label \citet{Bivens2017-tc}. 

  \Glspl{cmp} are immensely useful objects, as they do not require human intervention or labor to carry out their intended purpose. If the required material resource are made available to the composite, it will continue until it exhausts its resources or is stopped. Humans may set them up without any knowledge of their internals and without easy insight into the details of their function. This makes them powerful conduits for systems of control and surveillance. 

  However, due to their complexity, \glspl{cmp}' behavior is unpredictable. How changes made to a component will appear in the behavior the assembled \gls{cmp} is difficult, sometimes impossible\sepfootnote{softwaretoo}, to predict. Multiple components or layers of assembly can overlap in confusing ways\footnotemark. \Gls{cmp} makers respond to this quality by implementing systems of surveillance to observe and verify their own creations. These systems of surveillance often involve \glspl{cmp} with many overlapping components whose purpose is to observe internal behavior and report on internal behavior. Assembled \glspl{cmp} may have similar self-surveillance functions, though like all functions, these qualities run the risk of accidental subversion.

  \footnotetext{See \textbf{Other flaws}.}

  \sepfootnotecontent{softwaretoo}{For software, situations where prediction is impossible are quite common \citep{Kaplan_undated-xy}. There is nothing that requires composites to be software, per-se, however, and any sufficiently complex mechanistic assembly would meet this requirement.}

  \subsection{Composites in Society}
  Composites are a socially important departure from the way that 

  

% ============================================
% =   ____ _                                 =
% =  / ___| | ___  ___ ___  __ _ _ __ _   _  =
% = | |  _| |/ _ \/ __/ __|/ _` | '__| | | | =
% = | |_| | | (_) \__ \__ \ (_| | |  | |_| | =
% =  \____|_|\___/|___/___/\__,_|_|   \__, | =
% =                                   |___/  =
% ============================================
   \singlespacing
   \printnoidxglossaries

% =================================
% =  _____     _     _            =
% = |_   _|_ _| |__ | | ___  ___  =
% =   | |/ _` | '_ \| |/ _ \/ __| =
% =   | | (_| | |_) | |  __/\__ \ =
% =   |_|\__,_|_.__/|_|\___||___/ =
% =================================                             

   \section{Tables}
   These tables are missing some information that is available in this google sheet: \url{https://docs.google.com/spreadsheets/d/1fi5cNCA1mQgS8gZ7VL7MfalSXNQoD2pM1vC3uH18cNw/edit}. Additionally, the contributor who is identified as 'sherdim' used their real name, but I was unable to get \LaTeX to display their name properly, so I have used their github handle. Their profile can be found here: \url{https://github.com/sherdim}.

\begin{table}[ht]
\caption{Eden Contributors}
\label{tab:contribs-1}
\begin{tabular}{|l|r|r|}
\hline
Name            & Related Changes & Total Changes \\ \hline
Ashwyn          & 23              & 7,580         \\ \hline
Aviral Dasgupta & 88              & 6,147         \\ \hline
biplovbhandari  & 6               & 26,692        \\ \hline
Daniel Drexler  & 69              & 10,342        \\ \hline
Dominic König   & 14,070          & 1,940,890     \\ \hline
Fran Boon       & 12,314          & 3,816,361     \\ \hline
Graeme Foster   & 236             & 241,090       \\ \hline
hitesh96db      & 4               & 13,588        \\ \hline
James O'Neill   & 4               & 4,038         \\ \hline
Kunal Hari      & 11              & 8,920         \\ \hline
Michael Howden  & 313             & 143,771       \\ \hline
Pratyush Nigam  & 104             & 290           \\ \hline
raj454raj       & 1               & 10,917        \\ \hline
redsin          & 278             & 25,265        \\ \hline
tirgil          & 2               & 3,804         \\ \hline
VishrutMehta    & 2               & 1,153         \\ \hline
\end{tabular}
\end{table} 

\begin{table}[ht]
\caption{pydal Contributors 1}
\label{tab:contribs-2.1}
\begin{tabular}{|l|r|r|}
\hline
Name                 & Related Changes & Total Changes \\ \hline
abastardi            & 9               & 15            \\ \hline
alan                 & 2               & 11            \\ \hline
boa-py               & 2               & 2             \\ \hline
BuhtigithuB          & 670             & 5,524         \\ \hline
Cássio Botaro        & 2               & 2             \\ \hline
Christophe Varoqui   & 2               & 2             \\ \hline
Dan Feeney           & 11              & 11            \\ \hline
David Orme           & 30             & 30            \\ \hline
Dominic König        & 13              & 43            \\ \hline
dz0                  & 1               & 1             \\ \hline
Emmanuel Goh         & 4               & 4             \\ \hline
Fran Boon            & 3               & 21            \\ \hline
Francisco Tomé Costa & 4               & 4             \\ \hline
gi0baro              & 14,046          & 69,785        \\ \hline
Giovanni Barillari   & 6,112           & 8,240         \\ \hline
ilvalle              & 1,968           & 37,158        \\ \hline
Jack Kuan            & 7               & 7             \\ \hline
JusticeN             & 15              & 15            \\ \hline
jvanbraekel          & 40              & 40            \\ \hline
kvanzuijlen          & 2               & 2             \\ \hline
Leonel Câmara        & 191             & 896           \\ \hline
\end{tabular}
\end{table}

\begin{table}[ht]
\caption{pydal Contributors 2}
\label{tab:contribs-2.2}
\begin{tabular}{|l|r|r|}
\hline
Name                 & Related Changes & Total Changes \\ \hline
Martin Doucha        & 1,992           & 3,037         \\ \hline
maxcrystal           & 11              & 11            \\ \hline
Massimo DiPierro     & 6,320           & 903,691       \\ \hline
Michael Loster       & 2               & 2             \\ \hline
Michele Comitini     & 52              & 5,975         \\ \hline
nikakis              & 18              & 18            \\ \hline
niphlod              & 816             & 30,396        \\ \hline
preactive            & 2               & 2             \\ \hline
Remco Boerma         & 5               & 5             \\ \hline
Richard Boß          & 5               & 5             \\ \hline
rodwatkins           & 14              & 14            \\ \hline
Stephen Rauch        & 2,852           & 4,993         \\ \hline
Stephen Tanner       & 7               & 43            \\ \hline
Tim Nyborg           & 6               & 6             \\ \hline
Tom Stratton         & 9               & 9             \\ \hline
Victor Salgado       & 12              & 18            \\ \hline
Vinyl Darkscratch    & 2               & 49            \\ \hline
Wanderson Reis       & 5               & 5             \\ \hline
willimoa             & 7               & 64            \\ \hline
xuyangbocn           & 2               & 2             \\ \hline
\end{tabular}
\end{table}

\begin{table}[ht]
\caption{yatl Contributors}
\label{tab:contribs-4}
\begin{tabular}{|l|r|r|}
\hline
Name                           & Related Changes & Total Changes \\ \hline
Carlos Cesar Caballero Díaz    & 17              & 17            \\ \hline
Massimo DiPierro               & 1,689           & 2,089         \\ \hline
PhanterJR                      & 127             & 263           \\ \hline
\end{tabular}
\end{table}

\begin{table}[ht]
\caption{web2py Contributors 1}
\label{tab:contribs-3-1}
\begin{tabular}{|l|r|r|}
\hline
Name                           & Related Changes & Total Changes \\ \hline
abastardi                      & 27              & 153           \\ \hline
Adam Bryzak                    & 2               & 2             \\ \hline
Alexander Zayats               & 8               & 8             \\ \hline
alexdba                        & 17              & 17            \\ \hline
Alfonso de la Guarda Reyes     & 19              & 63            \\ \hline
Anssi Hannula                  & 10              & 12            \\ \hline
Batchu Venkat Vishal           & 2               & 2             \\ \hline
Carlos Cesar Caballero Díaz    & 34              & 3,136         \\ \hline
Carlos Costa                   & 13              & 236           \\ \hline
Cássio Botaro                  & 22              & 207           \\ \hline
cccaballero                    & 10              & 138           \\ \hline
Chen Rotem Levy                & 8               & 309           \\ \hline
Chris DeGroot                  & 4               & 4             \\ \hline
Chris Garcia                   & 12              & 34            \\ \hline
clach04                        & 45              & 45            \\ \hline
Daniel Libonati                & 2               & 9             \\ \hline
Denis Rykov                    & 4               & 4             \\ \hline
Dinis                          & 4               & 470           \\ \hline
Dominic König                  & 2               & 10            \\ \hline
Donald McClymont               & 7               & 7             \\ \hline
Erik Montes                    & 2               & 147           \\ \hline
Fran Boon                      & 11              & 28            \\ \hline
geomapdev                      & 153             & 223           \\ \hline
gi0baro                        & 12,022          & 38,807        \\ \hline
Giovanni Barillari             & 65              & 346           \\ \hline
hectord                        & 6               & 6             \\ \hline
ilvalle                        & 1,019           & 65,421        \\ \hline
Jack Kuan                      & 8               & 24            \\ \hline
Jan Beilicke                   & 13              & 13            \\ \hline
Jan M. Knaup                   & 12              & 12            \\ \hline
Jaripekkaf                     & 56              & 56            \\ \hline
Jeremie Dokime                 & 14              & 54            \\ \hline
Joel Rathgaber                 & 22              & 22            \\ \hline
Jonathan Bohren                & 57              & 59            \\ \hline
Jonathan Vasek                 & 2               & 2             \\ \hline
Jose C                         & 1               & 1             \\ \hline
jvanbraekel                    & 62              & 108           \\ \hline
kelson                         & 35              & 306           \\ \hline
Kiran Subbaraman               & 88              & 99            \\ \hline
Koen van Zuijlen               & 4               & 8             \\ \hline
Kristján Valur Jónsson         & 2               & 2             \\ \hline
\end{tabular}
\end{table}

\begin{table}[ht]
\caption{web2py Contributors 2}
\label{tab:contribs-3-2}
\begin{tabular}{|l|r|r|}
\hline
Name                           & Related Changes & Total Changes \\ \hline
Kurt Grutzmacher               & 352             & 2,378         \\ \hline
Leonel Câmara                  & 1,236           & 14,051        \\ \hline
Lisandro                       & 8               & 14            \\ \hline
Luca de Alfaro                 & 2               & 2             \\ \hline
Martin Doucha                  & 51              & 99            \\ \hline
Massimo DiPierro               & 76,420          & 825,014       \\ \hline
Mathieu Clabaut                & 24              & 88            \\ \hline
mcabo                          & 28              & 28            \\ \hline
Michele Comitini               & 1,284           & 6034          \\ \hline
mictee                         & 33              & 71            \\ \hline
Mirko Galimberti               & 11              & 52            \\ \hline
mpranjic                       & 6               & 36            \\ \hline
Nik Klever                     & 7               & 45            \\ \hline
niphlod                        & 6,304           & 45,996        \\ \hline
Oleg                           & 41              & 43            \\ \hline
Omar Trinidad Gutiérrez Méndez & 7               & 321           \\ \hline
omniavx                        & 2               & 2             \\ \hline
Oscar Fonts                    & 16              & 585           \\ \hline
Oscar Rodriguez                & 66              & 66            \\ \hline
Paolo Caruccio                 & 6               & 475           \\ \hline
Prasad Muley                   & 23              & 23            \\ \hline
Radu Ioan Fericean             & 30              & 66            \\ \hline
Ricardo Pedroso                & 108             & 263           \\ \hline
Richard Vézina                 & 5,135           & 17,379        \\ \hline
samuel bonilla                 & 4               & 93            \\ \hline
Scimonster                     & 4               & 6             \\ \hline
Seth Kinast                    & 10              & 18            \\ \hline
spametki                       & 473             & 3,404         \\ \hline
Stefan Pochmann                & 114             & 114           \\ \hline
tiago.bar                      & 2               & 4             \\ \hline
tim                            & 2               & 2             \\ \hline
Tim Nyborg                     & 43              & 109           \\ \hline
Tim Richardson                 & 222             & 337           \\ \hline
viniciusban                    & 18              & 261           \\ \hline
Vinyl Darkscratch              & 150             & 121,159       \\ \hline
winniehell                     & 5               & 5             \\ \hline
zvolsky                        & 11              & 1,543         \\ \hline
sherdim                        & 2               & 14            \\ \hline
\end{tabular}
\end{table}
   \setlength{\parindent}{4em}
   \bibliography{Final_Draft}

\end{document}
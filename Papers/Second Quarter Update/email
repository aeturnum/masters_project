Hello All,

I'm writing today to mark the end of the second quarter of my master's project and to give the committee an update about progress and where the project stands now.

When I originally embarked on this project, one of the goals was to try and combine situated knowledges discourse with the aims of situated intervention. How does situating the views of those who create software help us modify software? Can this theory help us effectuate change? I believe I'm at a point where I have my answer for this question.

Answering the question in full will require me to articulate a model of "what software is," as I've been unable to find an appropriate one within the software studies literature. I'm somewhat anxious about this, as the claim that the literature hasn't defined software seems pretty major. Anxiety aside, I'm feeling very satisfied with how the project is progressing (though I wish I could make progress more quickly - at times I've struggled to work).

I recently wrote a short piece that attempts to describe "what software is" and I've attached it to this email. I believe that D and O have read it already. What I was groping towards is that the common understanding of software-as-executable-object or software-as-text-that-is-read(executed)-by-the-computer are flattenings that hide important details of how software comes to exist and comes to impact the world. Instead, I'll be setting forth a layered model of software where the source code of "the software" is in the center. As we move away from the piece of source code belonging to "the software" and begin to encompass the components that must be assembled (but which don't, I *think*, form an assemblage) in order for the source code of "the program" to become *a program*, we incorporate other software-hardware-objects. First we have libraries referenced by "the program", each one with its own source code (and often, own libraries). Then we have the particular operating system of the host computer, the hardware of the host computer and finally the client computer (which is sometimes the same physical computer as the host computer) that communicates with the host computer to access "the software". Every element in this layered diagram influences the functioning of software. Unlike assemblages, which often focus on the interactions between component parts[0], this diagram describes a *composite object* - something made up of elements of different origins and characters, in which the nature of the links between the heterogeneous materials have material implications on how the composite functions, but which can reasonably to be understood and interacted with as a single thing. To say "a software program" exists is not a flattening - it does exist. However, crucially, the linkages between composite components and the character of the individual components have unequal agentic power for what the software "does" when it is executed. At the same time, the failure[1] of any of these *composite* components causes the entire composite to cease functioning. These individual components and links, generally invisible to the end user, are highly visible to the creators of software. You see here the relationality of software Makenzie so compellingly describes.

Back to situated knowledges. My notion, at the start of this project, was to find the use of situated knowledges on software. If software has problems that proceed from the situation of developers, what good does it to see that situation? Does it help us intercede and improve the situation, or does it "simply" (there is of course nothing simple about it) give us a general sense of epistemological superiority? I believe that we can identify unacknowledged limited perspectives that are encoded in "the software." I believe I've found at least one. I also believe that the standpoint of developers are limited to the inner-most two ring rings ("source code" and "libraries"). Developers understand the rest of the composite exists, but it exists in spaces outside of the control of the developer, and so while they can speak *about it,* their perspective impacts it to a limited extent.

I saw this in the (very) minor bug I found in EDEN: when entering a phone number that did not conform to requirements in a particular place, the user would not see the correct error message. In particular, the error message should insist that the phone number be in international format (+<country code><local number>). This requirement isn't displayed anywhere in the user interface. This (completely reasonable and unproblematic) default likely comes from the international and multi-national audience for EDEN. It is also an tiny, perfect example of a material standpoint encoded into the software: the unstated[2] assumption that numbers will be international and users will implicitly know this. I submitted a fix for this problem (my fix was immediately and gently rejected for coding flaws) and the developer acknowledged I had found a bug ("flaw in functionality"). However, they situated this bug in a way that, to me, supports the layered model of software I outline above: "A wrong error message [client layer - the outer-most layer] is an annoyance, but neither does it break the intended functionality [source code / library layer - inner layers], nor does it jeopardize the data integrity[.]"[2] 

To me, this statement highlights the limits of standpoint analysis and critique: there are multiple layers of "working," which can exist at different layers of software. Developers think about software with these layers "exploded" (as supported by Makenzie), considering and managing relationships between them and carefully assigning agency for perceptions of failure to different layers. That the wrong message is shown cannot be reduced to the software not working - it both worked and didn't. It also suggests deep limitations to standpoint critique of these systems: the agentic power of developers diminishes as we move out from the central source code layer. This is true both in their conception and the material reality. However, for end users, this system of layers is totally flattened: if their phone number is rejected, it doesn't make any difference what layer is at fault, the system "doesn't work." Both groups are correct - the system works and doesn't - and so the efficacy of standpoint analysis is deeply limited. The only way to understand the impact of the developers' standpoint is to deeply engage in the developers' perspective, diving into the details of the software. The biases and perspectives held by developers are *real*, but their relationship to the experience had by an end end user is deeply uncertain. The critique of a "view from nowhere" requires a "view from nowhere" exist, but in this case it does not: developers are situated within software, end users from outside. 

This leads me to my choice of software intervention: an attempt to bring forward these various layers onto the surface of the flattened final form. Eden has over a million lines of code, I haven't counted the lines of code in all its supporting libraries - but that is the general idea. In so far as is possible I'm going to alter EDEN so it annotates how many lines of code, years of combined existence, and individual human authors have contributed to the various pieces of the software. Different elements of EDEN rest on top of different linkages within EDEN's own code and between EDEN and other libraries. Those differences can be represented (though not totalized) by summing up the statistics about the code and representing them in the web interface. That is what I hope to be able to do.

There are other directions for future work here: insubstantial and invisible labor, assemblages, and actor network theory at least. I will be reading a some literature at this point, but the bulk of the work will be setting down the theoretical backing, explaining my reasoning as to the limited usefulness of situated knowledges, and of course working on my intervention. 

I hope that is all to your liking and seems like it is on solid theoretical and methodological grounds. I will be in California for the next two weeks (given Corvid-19, perhaps longer), but I am happy to remotely meet with any of you to explain further or address concerns. 

[0] I need to conform this is the case in the literature but it's my understanding now
[1] There are failures and there are *failures*. When your phone does not have an internet connection and cannot load a web page, the software has not failed. It has successfully tried to contact a remote host, observed the failure of that process and informed the user. This process could be improved, but is an example of software *working.* The failures I discuss here are ones where elements of the composite experience unexpected failures - such as when your phone's web browser suddenly closes for no apparent reason or when your computer screen flashes blue and the computer restarts. These latter kind of failures represent a total collapse of the flattened software-object and such a collapse can be caused by any component failing to act as expected.
[2] Unstated is perhaps too strong a statement, as there is a setting that admins can change to allow non-international format numbers. It is totally unflagged for the user, who may or may not be an admin, and so I think "unstated" will serve. 
[3] https://github.com/sahana/eden/pull/1531